###############################################################################
# Copyright (c) 2000, 2021 IBM Corporation and others.
#
# This program and the accompanying materials
# are made available under the terms of the Eclipse Public License 2.0
# which accompanies this distribution, and is available at
# https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Contributors:
#     IBM Corporation - initial API and implementation
#		Benjamin Muskalla - Contribution for bug 239066
#		Fraunhofer FIRST - extended API and implementation
#		Technical University Berlin - extended API and implementation
#		Stephan Herrmann <stephan@cs.tu-berlin.de> - Contributions for 
#							bug 185682 - Increment/decrement operators mark local variables as read
#							bug 349326 - [1.7] new warning for missing try-with-resources
#							bug 186342 - [compiler][null] Using annotations for null checking
#							bug 365662 - [compiler][null] warn on contradictory and redundant null annotations
#							bug 365531 - [compiler][null] investigate alternative strategy for internally encoding nullness defaults
#							bug 365859 - [compiler][null] distinguish warnings based on flow analysis vs. null annotations
#							bug 374605 - Unreasonable warning for enum-based switch statements
#							bug 382353 - [1.8][compiler] Implementation property modifiers should be accepted on default methods.
#							bug 382347 - [1.8][compiler] Compiler accepts incorrect default method inheritance
#							bug 388281 - [compiler][null] inheritance of null annotations as an option
#							bug 381443 - [compiler][null] Allow parameter widening from @NonNull to unannotated
#							bug 331649 - [compiler][null] consider null annotations for fields
#							bug 393719 - [compiler] inconsistent warnings on iteration variables
#							bug 392862 - [1.8][compiler][null] Evaluate null annotations on array types
#							bug 382789 - [compiler][null] warn when syntactically-nonnull expression is compared against null
#							bug 402028 - [1.8][compiler] null analysis for reference expressions
#							bug 401796 - [1.8][compiler] don't treat default methods as overriding an independent inherited abstract method
#							bug 404649 - [1.8][compiler] detect illegal reference to indirect or redundant super
#							Bug 392099 - [1.8][compiler][null] Apply null annotation on types for null analysis
#							Bug 415043 - [1.8][null] Follow-up re null type annotations after bug 392099
#							Bug 392238 - [1.8][compiler][null] Detect semantically invalid null type annotations
#							Bug 416307 - [1.8][compiler][null] subclass with type parameter substitution confuses null checking
#							Bug 400874 - [1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)
#							Bug 424637 - [1.8][compiler][null] AIOOB in ReferenceExpression.resolveType with a method reference to Files::walk
#							Bug 418743 - [1.8][null] contradictory annotations on invocation of generic method not reported
#							Bug 416190 - [1.8][null] detect incompatible overrides due to null type annotations
#							Bug 392245 - [1.8][compiler][null] Define whether / how @NonNullByDefault applies to TYPE_USE locations
#							Bug 430150 - [1.8][null] stricter checking against type variables
#							Bug 434600 - Incorrect null analysis error reporting on type parameters
#							Bug 439516 - [1.8][null] NonNullByDefault wrongly applied to implicit type bound of binary type
#							Bug 438467 - [compiler][null] Better error position for "The method _ cannot implement the corresponding method _ due to incompatible nullness constraints"
#							Bug 458361 - [1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()
#							Bug 410218 - Optional warning for arguments of "unexpected" types to Map#get(Object), Collection#remove(Object) et al.
#		Jesper S Moller <jesper@selskabet.org> - Contributions for
#							bug 382701 - [1.8][compiler] Implement semantic analysis of Lambda expressions & Reference expression
#							bug 384567 - [1.5][compiler] Compiler accepts illegal modifiers on package declaration
#							Bug 412153 - [1.8][compiler] Check validity of annotations which may be repeatable
#							Bug 412151 - [1.8][compiler] Check repeating annotation's collection type
#							Bug 419209 - [1.8] Repeating container annotations should be rejected in the presence of annotation it contains
#							Bug 527554 - [18.3] Compiler support for JEP 286 Local-Variable Type
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved to a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The nested type {0} cannot be referenced using its binary name
7 = The type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}
18 = The static member type {0}.{1} should be accessed directly
19 = Type mismatch: cannot convert from {0} to {1}
20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
25 = Cannot refer to the non-final local variable {0} defined in an enclosing scope
26 = The member interface {0} can only be defined inside a top-level class or interface or in a static context
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}
30 = The member annotation {0} can only be defined inside a top-level class or interface or in a static context
31 = The member enum {0} can only be defined inside a top-level class or interface or in a static context
32 = The member enum {0} must be defined inside a static member type
33 = The type {0} is hiding the type {1}
34 = {0} is not an annotation type

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
###[obsolete] 53 = An array of void is an invalid type for the variable {0}
54 = void[] is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate parameter {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment
59 = The parameter {0} should not be assigned
60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The value of the local variable {0} is not used
62 = The value of the parameter {0} is not used
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many parameters, parameter {0} is exceeding the limit of 255 words eligible for method parameters
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic parameters, emulated parameter {0} is exceeding the limit of 255 words eligible for method parameters
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {1}.{0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The value of the field {0}.{1} is not used
78 = The static field {0}.{1} should be accessed directly
79 = Unqualified access to the field {0}.{1} 
80 = The final field {0}.{1} cannot be assigned
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned
83 = {0} cannot be resolved to a variable
84 = This static method of interface {0} can only be accessed as {0}.{1}
85 = The value of the exception parameter {0} is not used
86 = The code for the switch table on enum {0} is exceeding the 65535 bytes limit

90 = The local variable {0} is hiding another local variable defined in an enclosing scope
91 = The local variable {0} is hiding a field from type {1}
92 = The field {0}.{1} is hiding another local variable defined in an enclosing scope
93 = The field {0}.{1} is hiding a field from type {2}
94 = The parameter {0} is hiding another local variable defined in an enclosing scope
95 = The parameter {0} is hiding a field from type {1}
96 = The serializable class {0} does not declare a static final serialVersionUID field of type long
97 = Lambda expression''s parameter {0} cannot redeclare another local variable defined in an enclosing scope. 
98 = Lambda expression''s local variable {0} cannot redeclare another local variable defined in an enclosing scope. 
99 = The type {0} from the descriptor computed for the target context is not visible here.  
100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The method {1}({2}) from the type {0} is never used locally
119 = The static method {1}({2}) from the type {0} should be accessed directly 
120 = The method {1}({2}) from the type {0} refers to the missing type {3}
121 = The method {1}({2}) from the type {0} can be declared as static
122 = The method {1}({2}) from the type {0} can potentially be declared as static
123 = Ambiguous method reference: both {1}({2}) and {3}({4}) from the type {0} are eligible
124 = The method {1}({2}) from the type {0} should be accessed in a static way 
125 = Incompatible parameter list for array constructor. Expected (int), but found ({1})
126 = Constructed array {0} cannot be assigned to {1} as required in the interface descriptor  
127 = The type {0} does not define {1}({2}) that is applicable here
128 = The type of {0}({1}) from the type {2} is {3}, this is incompatible with the descriptor''s return type: {4}
129 = The constructor {0}({1}) refers to the missing type {2}
130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
134 = The constructor {0}({1}) is never used locally
135 = Cannot refer to an instance field {0} while explicitly invoking a constructor
136 = Cannot refer to an instance method while explicitly invoking a constructor
137 = Recursive constructor invocation {0}({1})
138 = Cannot refer to 'this' nor 'super' while explicitly invoking a constructor
139 = Constructor call must be the first statement in a constructor
140 = Implicit super constructor {0}({1}) is undefined for default constructor. Must define an explicit constructor
141 = Implicit super constructor {0}({1}) is not visible for default constructor. Must define an explicit constructor
142 = Implicit super constructor {0}({1}) is ambiguous for default constructor. Must define an explicit constructor
143 = Implicit super constructor {0}({1}) is undefined. Must explicitly invoke another constructor
144 = Implicit super constructor {0}({1}) is not visible. Must explicitly invoke another constructor
145 = Implicit super constructor {0}({1}) is ambiguous. Must explicitly invoke another constructor
146 = Default constructor cannot handle exception type {0} thrown by implicit super constructor. Must define an explicit constructor
147 = Unhandled exception type {0} thrown by implicit super constructor


148 = The allocated object is never used
149 = Dead code
150 = The type of the expression must be an array type but it resolved to {0}
151 = Must explicitly convert the char[] to a String
152 = String constant is exceeding the limit of 65535 bytes of UTF8 encoding
153 = case expressions must be constant expressions
154 = The literal {1} of type {0} is out of range 
156 = Cannot cast from {0} to {1}
157 = Cannot instantiate the type {0}
158 = Cannot define dimension expressions when an array initializer is provided
159 = Variable must provide either dimension expressions or an array initializer
160 = The operator {0} is undefined for the argument type(s) {1}
161 = Unreachable code
162 = Cannot return from within an initializer
163 = Initializer does not complete normally
164 = Expression must return a value
165 = Unreachable catch block for {0}. Only more specific exceptions are thrown and they are handled by previous catch block(s).
166 = The default case is already defined
167 = Unreachable catch block for {0}. This exception is never thrown from the try statement body
168 = Unhandled exception type {0}
169 = Cannot switch on a value of type {0}. Only convertible int values or enum variables are permitted
170 = Duplicate case
171 = Duplicate label {0}
172 = break cannot be used outside of a loop or a switch
173 = continue cannot be used outside of a loop
174 = The label {0} is missing
175 = {0} is not a valid type''s argument for the synchronized statement
176 = null is not a valid argument for the synchronized statement
177 = Cannot throw null as an exception
178 = The assignment to variable {0} has no effect
179 = Possible accidental assignment in place of a comparison. A condition expression should not be reduced to an assignment
180 = Unnecessary semicolon
181 = Unnecessary cast from {0} to {1}
182 = Unnecessary cast from {0} to {1}. It is already compatible with the argument type {2}
183 = The expression of type {0} is already an instance of type {1}
184 = finally block does not complete normally
185 = The declared exception {3} is not actually thrown by the method {1}({2}) from type {0}
186 = The declared exception {2} is not actually thrown by the constructor {0}({1})
187 = Unreachable catch block for {0}. It is already handled by the catch block for {1}
188 = Empty control-flow statement
189 = Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally
190 = Read access to enclosing field {0}.{1} is emulated by a synthetic accessor method
191 = Write access to enclosing field {0}.{1} is emulated by a synthetic accessor method
192 = Access to enclosing method {1}({2}) from the type {0} is emulated by a synthetic accessor method
193 = Access to enclosing constructor {0}({1}) is emulated by a synthetic accessor method
194 = Switch case may be entered by falling through previous case. If intended, add a new comment //$FALL-THROUGH$ on the line above
195 = The method {1} is defined in an inherited type and an enclosing scope
196 = The field {0} is defined in an inherited type and an enclosing scope 
197 = The type {0} is defined in an inherited type and an enclosing scope
198 = Cannot allocate the member type {0} using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type
199 = The label {0} is never explicitly referenced
200 = Cannot use {0} in a static context
201 = Cannot make a static reference to the non-static method {1}({2}) from the type {0}
202 = Cannot specify an array dimension after an empty dimension
#203 = Invalid cast expression
204 = Syntax error on token "{0}", {1} expected
205 = Syntax error on token "{0}", no accurate correction available
206 = Invalid argument to operation ++/--
207 = Interfaces cannot have constructors
208 = Array constants can only be used in initializers
209 = Syntax error on keyword "{0}"; {1} expected
210 = Syntax error on keyword "{0}", no accurate correction available
211 = Comparing identical expressions
212 = Type {0} cannot be safely cast to {1}

220 = Unmatched bracket
221 = The primitive type {0} of {1} does not have a field {2}
222 = Invalid expression as statement
223 = The left-hand side of an assignment must be a variable
224 = Missing semicolon
225 = Invalid parenthesized expression
226 = super reference is illegal in interface context

230 = Syntax error on token "{0}", {1} expected before this token
231 = Syntax error on token "{0}", {1} expected after this token
232 = Syntax error on token "{0}", delete this token
233 = Syntax error on tokens, delete these tokens
234 = Syntax error on tokens, they can be merged to form {0}
235 = Syntax error on token "{0}", invalid {1}
236 = Syntax error on token(s), misplaced construct(s)
237 = Syntax error on tokens, {0} expected instead
238 = Syntax error on tokens, no accurate correction available
239 = Syntax error, unexpected {0}
240 = Syntax error, insert "{0}" to complete {1}
241 = Syntax error, insert "{0}" to complete scope
242 = Syntax error, insert "{0}" to complete phrase

250 = Unexpected end of file
251 = Invalid hex literal number
252 = Invalid octal literal number
253 = Invalid character constant
254 = Invalid escape sequence (valid ones are  \\b  \\t  \\n  \\f  \\r  \\"  \\'  \\\\ )
255 = Invalid input
256 = Invalid unicode
257 = Invalid float literal number
258 = Null source string
259 = String literal is not properly closed by a double-quote
260 = Unexpected end of comment
261 = Non-externalized string literal; it should be followed by //$NON-NLS-<n>$
262 = Invalid digit (valid ones are 0..9)
263 = Invalid low surrogate: must be within 0xDC00 and 0xDFFF
264 = Invalid high surrogate: must be within 0xD800 and 0xDBFF
265 = Unnecessary $NON-NLS$ tag
266 = Invalid binary literal number (only '0' and '1' are expected)
267 = Binary literals can only be used with source level 1.7 or greater
268 = Underscores have to be located within digits
269 = Underscores can only be used with source level 1.7 or greater
271 = This lambda expression refers to the missing type {0}
272 = Text block is not properly closed with the delimiter

280 = Discouraged access: {0}

300 = The interface {0} cannot define an initializer
301 = Duplicate modifier for the type {0}
302 = Illegal modifier for the class {0}; only public, abstract & final are permitted
303 = Illegal modifier for the interface {0}; only public & abstract are permitted
304 = Illegal modifier for the member class {0}; only public, protected, private, abstract, static & final are permitted
305 = Illegal modifier for the member interface {0}; only public, protected, private, abstract & static are permitted
306 = Illegal modifier for the local class {0}; only abstract or final is permitted
307 = Access restriction: {0}
308 = The class {0} can be either abstract or final, not both
309 = The interface member type {0} can only be public
310 = The member type {0} can only set one of public / protected / private
311 = The member type {0} cannot be declared static; static types can only be declared in static or top level types
312 = The type {0} cannot be the superclass of {1}; a superclass must be a class
313 = The type {1} cannot subclass the final class {0}
314 = Duplicate interface {0} for the type {1}
315 = The type {0} cannot be a superinterface of {1}; a superinterface must be an interface
316 = Cycle detected: the type {0} cannot extend/implement itself or one of its own member types
317 = Cycle detected: a cycle exists in the type hierarchy between {0} and {1}
318 = The nested type {0} cannot hide an enclosing type
319 = Duplicate nested type {0}
320 = No exception of type {0} can be thrown; an exception type must be a subclass of Throwable
321 = The package {0} collides with a type
322 = The type {1} collides with a package
323 = The type {1} is already defined
324 = The type {0} cannot be resolved. It is indirectly referenced from required .class files
325 = The public type {1} must be defined in its own file
###[obsolete] 326 = A package must be specified in {0} or a default package created
327 = The hierarchy of the type {0} is inconsistent
328 = The declared package "{1}" does not match the expected package "{0}"
329 = The type java.lang.Object cannot have a superclass or superinterfaces
330 = The type java.lang.Object must be a class
331 = Redundant superinterface {0} for the type {1}, already defined by {2}
332 = The type {0} should also implement hashCode() since it overrides Object.equals()
333 = The type {0} must be an abstract class to define abstract methods

###[obsolete] 330 = {0} cannot be resolved or is not a valid superclass
###[obsolete] 331 = Superclass {0} is not visible
###[obsolete] 332 = Superclass {0} is ambiguous
###[obsolete] 333 = Superclass {0} cannot be referenced using its binary name
###[obsolete] 334 = Superclass {0} is defined in an inherited type and an enclosing scope
###[obsolete] 335 = {0} cannot be resolved or is not a valid superinterface
###[obsolete] 336 = Superinterface {0} is not visible
###[obsolete] 337 = Superinterface {0} is ambiguous
###[obsolete] 338 = Superinterface {0} cannot be referenced using its binary name
###[obsolete] 339 = Superinterface {0} is defined in an inherited type and an enclosing scope

340 = Duplicate field {0}.{1}
341 = Duplicate modifier for the field {0}
342 = Illegal modifier for the field {0}; only public, protected, private, static, final, transient & volatile are permitted
343 = Illegal modifier for the interface field {0}.{1}; only public, static & final are permitted
344 = The field {0} can only set one of public / protected / private
345 = The field {0} can be either final or volatile, not both
346 = The field {0} cannot be declared static in a non-static inner type, unless initialized with a constant expression

###[obsolete] 350 = {2} cannot be resolved (or is not a valid type) for the field {1}.{0}
###[obsolete] 351 = The type {2} is not visible for the field {1}.{0}
###[obsolete] 352 = The type {2} is ambiguous for the field {1}.{0}
###[obsolete] 353 = The field type {2} cannot be referenced using its binary name
###[obsolete] 354 = The field type {2} is defined in an inherited type and an enclosing scope

355 = Duplicate method {0}({2}) in type {1}
356 = Illegal modifier for parameter {0}; only final is permitted
357 = Duplicate modifier for the method {1} in type {0}
358 = Illegal modifier for the method {0}; only public, protected, private, abstract, static, final, synchronized, native & strictfp are permitted
359 = Illegal modifier for the interface method {0}; only public & abstract are permitted
360 = The method {1} in type {0} can only set one of public / protected / private
361 = The method {1} cannot be declared static; static methods can only be declared in a static or top level type
362 = The abstract method {1} in type {0} can only set a visibility modifier, one of public or protected
363 = The abstract method {1} in type {0} can only be defined by an abstract class
364 = void is an invalid type for the parameter {1} of a method
###[obsolete] 365 = An array of void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 366 = An array of void is an invalid return type for the method {0}
367 = The native method {1} cannot also be declared strictfp
368 = Duplicate modifier for parameter {0}
369 = Illegal modifier for the constructor in type {0}; only public, protected & private are permitted

###[obsolete] 370 = {2} cannot be resolved (or is not a valid type) for the parameter {1} of the method {0}
###[obsolete] 371 = The type {2} is not visible for the parameter {1} of the method {0}
###[obsolete] 372 = The type {2} is ambiguous for the parameter {1} of the method {0}
###[obsolete] 373 = The parameter type {2} cannot be referenced using its binary name
###[obsolete] 374 = The parameter type {2} is defined in an inherited type and an enclosing scope
###[obsolete] 375 = {1} cannot be resolved (or is not an exception type) for the method {0}
###[obsolete] 376 = The exception type {1} is not visible for the method {0}
###[obsolete] 377 = The exception type {1} is ambiguous for the method {0}
###[obsolete] 378 = The exception type {1} cannot be referenced using its binary name
###[obsolete] 379 = The exception type {1} is defined in an inherited type and an enclosing scope
###[obsolete] 380 = {1} cannot be resolved (or is not a valid return type) for the method {0}
###[obsolete] 381 = The return type {1} is not visible for the method {0}
###[obsolete] 382 = The return type {1} is ambiguous for the method {0}
###[obsolete] 383 = The return type {1} cannot be referenced using its binary name
###[obsolete] 384 = The return type {1} is defined in an inherited type and an enclosing scope

385 = The import {0} conflicts with a type defined in the same file
386 = The import {0} collides with another import statement
387 = Only a type can be imported. {0} resolves to a package
388 = The import {0} is never used
390 = The import {0} cannot be resolved

###[obsolete] 391 = The imported type {0} is not visible
###[obsolete] 392 = The imported type {0} is ambiguous
###[obsolete] 393 = The imported type {0} cannot be referenced using its binary name
###[obsolete] 394 = The imported type {0} is defined in an inherited type and an enclosing scope

391 = The static import {0} must be a field or member type

395 = Duplicate modifier for the variable {0}
396 = Illegal modifier for the variable {0}; only final is permitted
###[obsolete] 397 = Redundant null check: The variable {0} cannot be null at this location
###[obsolete] 398 = Null pointer access: The variable {0} can only be null at this location
###[obsolete] 399 = Potential null pointer access: The variable {0} may be null at this location
	
400 = The type {3} must implement the inherited abstract method {2}.{0}({1})
401 = Cannot override the final method from {0}
402 = Exception {0} is not compatible with throws clause in {1}
403 = Exception {0} in throws clause of {1} is not compatible with {2}
404 = The return type is incompatible with {0}
405 = The inherited method {0} cannot hide the public abstract method in {1}
406 = This instance method cannot override the static method from {0}
407 = This static method cannot hide the instance method from {0}
408 = The static method {0} conflicts with the abstract method in {1}
409 = Cannot reduce the visibility of the inherited method from {0}
410 = The method {0} does not override the inherited method from {1} since it is private to a different package
411 = This class must implement the inherited abstract method {1}, but cannot override it since it is not visible from {0}. Either make the type abstract or make the inherited method visible
412 = The method {0} overrides a deprecated method from {1}
413 = The return type is incompatible with {0}, thus this interface cannot be implemented
414 = Exception {0} is not compatible with throws clause in {1}, thus this interface cannot be implemented
415 = The variable argument type {0} of the method {1} must be the last parameter
416 = The method {0} is overriding a method without making a super invocation
417 = The method {0}.{1}({2}) is overriding a synchronized method without being synchronized
418 = The type {3} must implement the inherited abstract method {2}.{0}({1}) to override {6}.{4}({5})
419 = The return types are incompatible for the inherited methods {0}

420 = Code snippet support cannot find the class {0}
421 = Code snippet support cannot find the method {0}.{1}({2}) 
422 = super cannot be used in the code snippet code

430 = Too many constants, the constant pool for {0} would exceed 65536 entries
431 = The type generates a string that requires more than 65535 bytes to encode in Utf8 format in the constant pool

432 = Too many fields for type {0}. Maximum is 65535
433 = Too many methods for type {0}. Maximum is 65535
434 = The synthetic method created to access {0}({1}) of type {2} has too many parameters

440 = 'assert' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on
441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
442 = Enum constants cannot be surrounded by parenthesis
443 = '_' should not be used as an identifier, since it is a reserved keyword from source level 1.8 on
444 = The uninterned types {0} and {1} should not be compared using ==/!= operators.
445 = '_' is a keyword from source level 9 onwards, cannot be used as identifier

450 = {0}{1}

451 = Null pointer access: The variable {0} can only be null at this location
452 = Potential null pointer access: The variable {0} may be null at this location
453 = Redundant null check: The variable {0} can only be null at this location
454 = Null comparison always yields false: The variable {0} can only be null at this location
455 = Redundant assignment: The variable {0} can only be null at this location
456 = instanceof always yields false: The variable {0} can only be null at this location
457 = Redundant null check: The variable {0} cannot be null at this location
458 = Null comparison always yields false: The variable {0} cannot be null at this location
459 = Potential null pointer access: This expression of type {0} may be null but requires auto-unboxing
461 = Null pointer access: This expression of type {0} is null but requires auto-unboxing
460 = Empty block should be documented

### DOC
462 = Invalid URL reference. Double quote the reference or use the href syntax
463 = Description expected after this reference
464 = Unexpected duplicated tag @{0}
465 = ''{0}'' visibility for malformed doc comments hides this ''{1}'' reference
466 = Invalid member type qualification
467 = Missing identifier
468 = Cannot make a static reference to the non-static type variable {0}
469 = Invalid param tag type parameter name
470 = Unexpected tag
471 = Missing tag for parameter {0}
472 = Missing parameter name
473 = Duplicate tag for parameter
474 = Parameter {0} is not declared
475 = Missing tag for return type
476 = Duplicate tag for return type
477 = Missing tag for declared exception {0}
478 = Missing class name
479 = Invalid class name
480 = Duplicate tag for thrown exception
481 = Exception {0} is not declared
482 = Missing reference
483 = Invalid reference
484 = Malformed link reference
485 = Invalid parameters declaration
486 = Missing comment for {0} declaration
487 = Invalid tag
488 = {0} cannot be resolved or is not a field
489 = The field {0} is not visible
490 = The field {0} is ambiguous
491 = The field {0}.{1} is deprecated
492 = The constructor {0}({1}) is undefined
493 = The constructor {0}({1}) is not visible
494 = The constructor {0}({1}) is ambiguous
495 = The constructor {0}({1}) is deprecated
496 = The method {1}({2}) is undefined for the type {0}
497 = The method {1}({2}) from the type {0} is not visible
498 = The method {1}({2}) is ambiguous for the type {0}
499 = The method {1}({2}) from the type {0} is deprecated
500 = Cannot invoke {1}({2}) on the primitive type {0}
501 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
502 = Cannot invoke {1}({2}) on the array type {0}
503 = {0} cannot be resolved to a type
504 = The type {0} is not visible
505 = The type {0} is ambiguous
506 = The type {0} is deprecated
507 = The nested type {0} cannot be referenced using its binary name
508 = The method {1} is defined in an inherited type and an enclosing scope
509 = The field {0} is defined in an inherited type and an enclosing scope 
510 = The type {0} is defined in an inherited type and an enclosing scope
511 = {0} is an ambiguous method reference or is not a field
512 = Missing closing brace for inline tag
513 = Malformed reference (missing end space separator)
514 = Javadoc: 
515 = Missing #: "{0}"
516 = Description expected after @{0}
517 = Only static field reference is allowed for @value tag
518 = Unexpected text
519 = Invalid param tag name

### GENERICS
520 = Duplicate type parameter {0}
521 = Cannot refer to the type parameter {0} as a supertype
522 = Cannot make a static reference to the non-static type {0}
523 = The type java.lang.Object cannot be declared as a generic
524 = The type {0} is not generic; it cannot be parameterized with arguments <{1}>
525 = Incorrect number of arguments for type {0}; it cannot be parameterized with arguments <{1}>
526 = Bound mismatch: The type {0} is not a valid substitute for the bounded parameter <{2} extends {3}> of the type {1}
527 = Erasure of method {0}({2}) is the same as another method in type {1}
528 = Illegal forward reference to type parameter {0}
529 = The type {0} is not an interface; it cannot be specified as a bounded parameter
530 = Type safety: The constructor {0}({1}) belongs to the raw type {0}. References to generic type {2} should be parameterized
531 = Type safety: The method {0}({1}) belongs to the raw type {2}. References to generic type {3} should be parameterized
532 = Type safety: The expression of type {0} needs unchecked conversion to conform to {1}
533 = Cannot use the type parameter {0} in a catch block
534 = Cannot use the parameterized type {0} either in catch block or throws clause
535 = Cannot create a generic array of {0}
536 = Type safety: The field {1} from the raw type {2} is assigned a value of type {0}. References to generic type {3} should be parameterized
537 = The type parameter {0} should not be bounded by the final type {1}. Final types cannot be further extended
538 = Inconsistent classfile encountered: The undefined type parameter {0} is referenced from within {1}
539 = The interface {2} cannot be implemented more than once with different arguments: {0} and {1}
540 = Bound mismatch: The constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
541 = Bound mismatch: The method {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
542 = Bound mismatch: Cannot assign expression of type {0} to wildcard type {1}. The wildcard type has no lower bound, and may actually be more restrictive than expression type
543 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
544 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
545 = Type safety: Unchecked cast from {0} to {1}
546 = Cannot perform instanceof check against parameterized type {0}. Use the form {1} instead since further generic type information will be erased at runtime
547 = Cannot perform instanceof check against type parameter {0}. Use its erasure {1} instead since further generic type information will be erased at runtime
548 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
549 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
550 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
551 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
552 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
553 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
554 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
555 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
556 = The type {1} cannot extend or implement {0}. A supertype may not specify any wildcard
557 = The generic class {0} may not subclass java.lang.Throwable
558 = Illegal class literal for the type parameter {0}
559 = Type safety: The return type {0} for {1}({2}) from the type {3} needs unchecked conversion to conform to {4} from the type {5}
560 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not override it
561 = The member type {0}<{1}> must be qualified with a parameterized type, since it is not static
562 = The member type {0} must be parameterized, since it is qualified with a parameterized type
563 = The member type {0} cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type {1}
###[obsolete] 564 = Bound conflict: {0} is inherited with conflicting arguments
565 = Duplicate methods named {0} with the parameters ({2}) and ({3}) are defined by the type {1}
566 = Cannot allocate the member type {0} using a parameterized compound name; use its simple name and an enclosing instance of type {1}
567 = Duplicate bound {0}
568 = The array type {0} cannot be used as a type parameter bound
569 = Type safety: Unchecked invocation {0}({3}) of the generic constructor {0}({1}) of type {2}
570 = Type safety: Unchecked invocation {0}({3}) of the generic method {0}({1}) of type {2}
571 = The type parameter {0} is hiding the type {1}
572 = {0} is a raw type. References to generic type {1} should be parameterized
573 = Cannot specify any additional bound {0} when first bound is a type parameter
574 = Type safety: A generic array of {0} is created for a varargs parameter
575 = Illegal qualified access from the type parameter {0}
576 = The nested type {0} is hiding the type parameter {1} of type {2}
577 = The nested type {0} is hiding the type parameter {1} of the generic method {2}({3}) of type {4}
578 = Wildcard is not allowed at this location
579 = Unused type arguments for the non generic method {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>
583 = Duplicate methods named {0} with the parameters ({1}) and ({2}) are inherited from the types {3} and {4}
584 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not hide it
586 = Type arguments are not allowed here

### FOREACH
580 = Type mismatch: cannot convert from element type {0} to {1}
581 = Can only iterate over an array or an instance of java.lang.Iterable
582 = Can only iterate over an array or an instance of java.util.Collection
585 = Type safety: Elements of type {0} need unchecked conversion to conform to {1}

### SOURCE LEVEL
590 = Syntax error, type parameters are only available if source level is 1.5 or greater
591 = Syntax error, static imports are only available if source level is 1.5 or greater
592 = Syntax error, 'for each' statements are only available if source level is 1.5 or greater
593 = Syntax error, parameterized types are only available if source level is 1.5 or greater
594 = Syntax error, enum declarations are only available if source level is 1.5 or greater
595 = Syntax error, varargs are only available if source level is 1.5 or greater
596 = Syntax error, annotations are only available if source level is 1.5 or greater
597 = Syntax error, annotation declarations are only available if source level is 1.5 or greater
598 = Syntax error, annotation declaration cannot have type parameters
599 = Syntax error, enum declaration cannot have type parameters

### ANNOTATIONS
600 = Illegal modifier for the annotation attribute {0}.{1}; only public & abstract are permitted
601 = Extended dimensions are illegal in an annotation attribute declaration
602 = Package annotations must be in file package-info.java
603 = Illegal modifier for the annotation type {0}; only public & abstract are permitted
604 = Illegal modifier for the member annotation type {0}; only public, protected, private, abstract & static are permitted
605 = Invalid type {0} for the annotation attribute {2}.{1}; only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof
606 = Cycle detected: the annotation type {0} cannot contain attributes of the annotation type itself
607 = Cycle detected: a cycle exists between annotation attributes of {0} and {1}
608 = Duplicate annotation @{0}. Repeated annotations are allowed only at source level 1.8 or above
609 = The annotation @{0} must define the attribute {1}
610 = Duplicate attribute {0} in annotation @{1}
611 = The attribute {0} is undefined for the annotation type {1}
612 = The value for annotation attribute {0}.{1} must be a class literal
613 = The value for annotation attribute {0}.{1} must be a constant expression
###[obsolete] 614 = The annotation field {0}.{1} must be initialized with a constant expression
615 = Illegal modifier for the annotation field {0}.{1}; only public, static & final are permitted
616 = The annotation type {0} cannot override the method {1}.{2}({3})
617 = Annotation attributes cannot have parameters
618 = Annotation attributes cannot be generic
619 = Annotation type declaration cannot have an explicit superclass
620 = Annotation type declaration cannot have explicit superinterfaces
621 = Duplicate element {0} specified in annotation @{1}
622 = The annotation @{0} is disallowed for this location
623 = The method {0}({1}) of type {2} must override a superclass method
624 = Annotation type declaration cannot have a constructor
625 = The value for annotation attribute {0}.{1} must be some @{2} annotation 
626 = The annotation type {0} should not be used as a superinterface for {1}
627 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superclass method
628 = The deprecated field {0}.{1} should be annotated with @Deprecated
629 = The deprecated method {0}({1}) of type {2} should be annotated with @Deprecated
630 = The deprecated type {0} should be annotated with @Deprecated
631 = Unsupported @SuppressWarnings("{0}")
632 = The value for annotation attribute {0}.{1} must be an array initializer
633 = The value for annotation attribute {0}.{1} must be an enum constant expression
634 = The method {0}({1}) of type {2} must override or implement a supertype method
635 = Unnecessary @SuppressWarnings("{0}")
636 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superinterface method
637 = Syntax error, type annotations are available only when source level is at least 1.8
638 = Explicit 'this' parameter is allowed only in instance methods of non-anonymous classes and inner class constructors
639 = Syntax error, type annotations are illegal here
640 = Type annotations are not allowed on type names used to access static members
641 = Type annotation is illegal for a method that returns void
642 = Only the first formal parameter may be declared explicitly as 'this'
643 = Explicit declaration of 'this' parameter is allowed only at source level 1.8 or above
644 = Default methods are allowed only at source level 1.8 or above
645 = Lambda expressions are allowed only at source level 1.8 or above
646 = Method references are allowed only at source level 1.8 or above
647 = Constructor references are allowed only at source level 1.8 or above
648 = Lambda expressions cannot declare a this parameter
649 = Annotation types that do not specify explicit target element types cannot be applied here
650 = The declared type of the explicit ''this'' parameter is expected to be {0}
651 = The explicit ''this'' parameter is expected to be qualified with {0}
652 = The explicit 'this' parameter for a method cannot have a qualifying name
653 = The target type of this expression must be a functional interface
654 = The variable argument type {0} of the lambda expression must be the last parameter
655 = The target type of this expression is not a well formed parameterized type due to bound(s) mismatch
656 = Lambda expression''s signature does not match the signature of the functional interface method {0}
657 = Lambda expression''s parameter {0} is expected to be of type {1}
658 = Incompatible type specified for lambda expression''s parameter {0}
659 = Illegal lambda expression: Method {0} of type {1} is generic 
### MORE GENERICS
660 = Unused type arguments for the non generic constructor {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>
661 = Unused type parameter {0}

### MORE TYPE RELATED
662 = Illegal attempt to create arrays of union types
663 = Local variable {0} defined in an enclosing scope must be final or effectively final
664 = Invalid ''@FunctionalInterface'' annotation; {0} is not a functional interface
665 = The constructed object of type {0} is incompatible with the descriptor''s return type: {1}
666 = Syntax error, type annotations are illegal here
667 = Super method references to interface default methods are allowed only at source level 1.8 or above
668 = References to interface static methods are allowed only at source level 1.8 or above
669 = Field {0} must be final

### NULL ANALYSIS FOR OTHER EXPRESSIONS
670 = Null comparison always yields false: this expression cannot be null
671 = Redundant null check: this expression cannot be null
672 = Null pointer access: This expression can only be null
673 = Potential null pointer access: This expression may be null

### CORRUPTED BINARIES
700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}

### CORRUPTED SOURCES
701 = Cannot read the source from {0}; either the file uses a different encoding than {1} or it is corrupted
702 = Cannot read the source from {0} due to internal exception {1}

### AUTOBOXING
720 = The expression of type {0} is boxed into {1}
721 = The expression of type {0} is unboxed into {1}

### MODIFIERS
741 = Floating-point expressions are always strictly evaluated from source level 17. Keyword 'strictfp' is not required.

### ENUMS
750 = Illegal modifier for the enum {0}; only public is permitted
751 = Illegal modifier for the enum constant {0}; no modifier is allowed
###[obsolete] 752 = Illegal modifier for the local enum {0}; only abstract is permitted
753 = Illegal modifier for the member enum {0}; only public, protected, private & static are permitted
754 = The enum {1} already defines the method {0}({2}) implicitly
755 = The qualified case label {0}.{1} must be replaced with the unqualified enum constant {1}
756 = The type {1} may not subclass {0} explicitly
757 = Cannot invoke super constructor from enum constructor {0}({1})
758 = The enum {2} can only define the abstract method {0}({1}) if it also defines enum constants with corresponding implementations
759 = The field {0}.{1} cannot be referenced from an enum case label; only enum constants can be used in enum switch
760 = Illegal modifier for the enum constructor; only private is permitted.
761 = The enum constant {1} needs a corresponding case label in this enum switch on {0}
762 = Cannot refer to the static enum field {0}.{1} within an initializer
763 = The enum constant {2} must implement the abstract method {0}({1})
764 = The enum constant {0} cannot define abstract methods
765 = The method {1} cannot be abstract in the enum constant {0}
766 = The switch over the enum type {0} should have a default case
767 = The switch statement should have a default case
768 = The enum constant {1} should have a corresponding case label in this enum switch on {0}. To suppress this problem, add a comment //$CASES-OMITTED$ on the line above the ''default:''
769 = The local variable {0} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
770 = The blank final field {0} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
771 = This method must return a result of type {0}. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem

### VARARGS
800 = Extended dimensions are illegal for a variable argument
801 = Type {0} of the last argument to method {2}({3}) doesn''t exactly match the vararg parameter type. Cast to {1} to confirm the non-varargs invocation, or pass individual arguments of type {5} for a varargs invocation.
802 = Type {0} of the last argument to constructor {2}({3}) doesn''t exactly match the vararg parameter type. Cast to {1} to confirm the non-varargs invocation, or pass individual arguments of type {4} for a varargs invocation.
803 = Varargs methods should only override or be overridden by other varargs methods unlike {2}.{0}({1}) and {4}.{0}({3})
804 = @SafeVarargs annotation cannot be applied to fixed arity method {0}
805 = @SafeVarargs annotation cannot be applied to non-final instance method {0}
806 = Type safety: Potential heap pollution via varargs parameter {0}
807 = The method {0}({1}) of type {2} is not applicable as the formal varargs element type {3} is not accessible here
808 = The constructor {0}({1}) of type {2} is not applicable as the formal varargs element type {3} is not accessible here
809 = The method {0}({1}) of type {2} cannot be invoked as it is overridden by an inapplicable method

### GENERIC JAVADOC
850 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
851 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
852 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
853 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
854 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
855 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
856 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
857 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
858 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
859 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>

### Java 7
870 = The parameter {0} of a multi-catch block cannot be assigned
871 = The resource type {0} does not implement java.lang.AutoCloseable
872 = The resource {0} of a try-with-resources statement cannot be assigned
873 = The exception {0} is already caught by the alternative {1}
874 = Resource specification not allowed here for source level below 1.7
875 = Multi-catch parameters are not allowed for source level below 1.7
876 = Invocation of polymorphic methods not allowed for source level below 1.7
877 = Cannot switch on a value of type {0}. Only convertible int values, strings or enum variables are permitted
878 = Cannot infer type arguments for {0}
879 = Explicit type arguments cannot be used with '<>' in an allocation expression
880 = '<>' cannot be used with anonymous classes
881 = Cannot switch on a value of type String for source level below 1.7. Only convertible int values or enum variables are permitted
882 = Unhandled exception type {0} thrown by automatic close() invocation on {1}
883 = '<>' operator is not allowed for source level below 1.7
884 = Redundant specification of type arguments <{0}>
885 = Potential resource leak: ''{0}'' may not be closed
886 = Potential resource leak: ''{0}'' may not be closed at this location
887 = Resource leak: ''{0}'' is never closed
888 = Resource leak: ''{0}'' is not closed at this location
889 = Resource ''{0}'' should be managed by try-with-resource
890 = Cannot switch on an enum value for source level below 1.5. Only convertible int values are permitted

#### Java 8
891 = Additional bounds are not allowed in cast operator at source levels below 1.8
892 = Base types are not allowed in intersection cast operator
893 = Arrays are not allowed in intersection cast operator
894 = Duplicate type in intersection cast operator
#[obsolete] 895 = The target type of this expression is not a functional interface: more than one of the intersecting interfaces are functional
896 = Static methods are allowed in interfaces only at source level 1.8 or above

897 = Duplicate annotation of non-repeatable type @{0}. Only annotation types marked @Repeatable can be used multiple times at one target.
898 = The annotation @{0} cannot be repeated at this location since its container annotation type @{1} is disallowed at this location
899 = The repeatable annotation @{0} may not be repeated where its container annotation type @{1} is also used directly
902 = The value method in the container annotation type @{0} must be of type {1}[] but is {2}
903 = The container annotation type @{0} must declare a member value()
904 = The container annotation type @{0} must declare a default value for the annotation attribute ''{1}''
905 = Retention ''{1}'' of @{0} is longer than the retention of its container annotation type @{2}, which is ''{3}''
906 = The container annotation type @{1} is allowed at targets where the repeatable annotation type @{0} is not: {2}
907 = The repeatable annotation type @{0} is marked @Documented, but its container annotation type @{1} is not
908 = The repeatable annotation type @{0} is marked @Inherited, but its container annotation type @{1} is not
909 = The repeatable annotation @{0} may not be present where its container annotation type @{1} is repeated

### NULL ANNOTATIONS
910 = Null type mismatch: required ''{0}'' but the provided value is null
911 = Null type mismatch: required ''{0}'' but the provided value is inferred as @{1}
912 = Null type safety: The expression of type ''{0}'' needs unchecked conversion to conform to ''{1}''
913 = A default nullness annotation has not been specified for the package {0}
914 = The return type is incompatible with ''{1}'' returned from {0} (mismatching null constraints)
915 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as @{2}
916 = Illegal redefinition of parameter {0}, inherited method from {1} does not constrain this parameter
917 = Missing non-null annotation: inherited method from {0} specifies this parameter as @{1}
918 = Missing nullable annotation: inherited method from {0} specifies this parameter as @{1}
919 = Potential null pointer access: The method {0} may return null
920 = Redundant null check: The method {0} cannot return null
921 = The method {0}{1}({2}) from {3} cannot implement the corresponding method from {4} due to incompatible nullness constraints
922 = The nullness annotation is redundant with a default that applies to this location
923 = The nullness annotation @{0} is not applicable for the primitive type {1}
924 = Potential null pointer access: The field {0} is specified as @{1}
925 = Nullness default is redundant with the global default
926 = Nullness default is redundant with a default specified for the enclosing package {0}
927 = Nullness default is redundant with a default specified for the enclosing type {0}
928 = Nullness default is redundant with a default specified for the enclosing method {0}
929 = Contradictory null specification; only one of @{0} and @{1} can be specified at any location
930 = A default nullness annotation has not been specified for the type {0}
931 = Redundant null check: The variable {0} is specified as @{1}
932 = Null comparison always yields false: The variable {0} is specified as @{1}
933 = Null type mismatch: required ''{0}'' but the provided value is specified as @{1}
934 = The @{0} field {1} may not have been initialized
935 = The @{0} field {1} may not have been initialized. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
936 = Null comparison always yields false: The method {0} cannot return null
937 = Redundant null check: The field {0} is specified as @{1}
938 = Null comparison always yields false: The field {0} is specified as @{1}
939 = The default ''@{0}'' conflicts with the inherited ''@{1}'' annotation in the overridden method from {2} 
940 = Conflict between inherited null annotations ''@{0}'' declared in {1} versus ''@{2}'' declared in {3} 
941 = Redundant null check: The field {0} cannot be null at this location (ignoring concurrency)
942 = Null comparison always yields false: The field {0} cannot be null at this location (ignoring concurrency)
943 = Nullness default is redundant with a default specified for the enclosing module {0}
944 = Redundant null check: The field {0} is a nonnull constant
945 = Null comparison always yields false: The field {0} is a nonnull constant
946 = Parameter {0} of method {1} lacks a @{3} annotation as specified in type {2}


951 = Potential null pointer access: array element may be null
952 = Potential null pointer access: this expression has a ''@{0}'' type
953 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}''
954 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}'', corresponding supertype is ''{2}''
955 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}''
956 = Null type safety (type annotations): The expression of type ''{1}'' needs unchecked conversion to conform to ''{0}'', corresponding supertype is ''{2}''
957 = Null type mismatch at parameter {0}: required ''{1}'' but provided ''{2}'' via method descriptor {3}
958 = Null type safety: parameter {0} provided via method descriptor {3} needs unchecked conversion to conform to ''{1}''
959 = Null type mismatch at method return type: Method descriptor {0} promises ''{1}'' but referenced method provides ''{2}''
960 = Null type safety at method return type: Method descriptor {0} promises ''{1}'' but referenced method provides ''{2}''
961 = Redundant null check: comparing ''{0}'' against null
962 = The nullness annotation ''{0}'' is not applicable at this location
963 = Nullness annotations are not applicable at this location 
964 = Null constraint mismatch: The type ''{1}'' is not a valid substitute for the type parameter ''{0}''
965 = This nullness annotation conflicts with a ''@{0}'' annotation which is effective on the same type parameter 
966 = Contradictory null annotations: method was inferred as ''{2} {3}({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
967 = Null type safety: Unchecked cast from {0} to {1}
#968 temporary warning has been removed
969 = Null type mismatch (type annotations): ''null'' is not compatible to the free type variable ''{0}''
970 = Null type mismatch (type annotations): required ''{0}'' but this expression has type ''{1}'', where ''{0}'' is a free type variable
971 = The explicit type bound 'Object' is not affected by the nullness default for DefaultLocation.TYPE_BOUND.
972 = Illegal redefinition of parameter {0}, inherited method from {1} declares this parameter as ''{2}'' (mismatching null constraints)
973 = Contradictory null annotations: function type was inferred as ''{2} ({4})'', but only one of ''@{0}'' and ''@{1}'' can be effective at any location
974 = The return type is incompatible with the free type variable ''{1}'' returned from {0} (mismatching null constraints)
975 = Cannot redefine null constraints of type variable ''{0}'' declared in ''{1}''
976 = Potential null pointer access: this expression has type ''{0}'', a free type variable that may represent a ''@{1}'' type
977 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type
978 = The field {0} may not have been initialized, whereas its type ''{1}'' is a free type variable that may represent a ''@{2}'' type. Note that a problem regarding missing ''default:'' on ''switch'' has been suppressed, which is perhaps related to this problem
979 = Null type safety: required ''@{0}'' but this expression has type ''{1}'', a free type variable that may represent a ''@{2}'' type
980 = Unsafe interpretation of method return type as ''@{0}'' based on the receiver type ''{1}''. Type ''{2}'' doesn''t seem to be designed with null type annotations in mind
981 = Unsafe interpretation of method return type as ''@{0}'' based on substitution ''{1}={2}''. Declaring type ''{3}'' doesn''t seem to be designed with null type annotations in mind
982 = Annotation type ''{0}'' cannot be found on the build path, which is implicitly needed for null analysis
983 = Unsafe null type conversion (type annotations): The value of type ''{1}'' is made accessible using the less-annotated type ''{0}''
984 = Unsafe null type conversion (type annotations): The value of type ''{1}'' is made accessible using the less-annotated type ''{0}'', corresponding supertype is ''{2}''

# Java 8
1001 = Syntax error, modifiers and annotations are not allowed for the lambda parameter {0} as its type is elided
1002 = Syntax error, modifiers are not allowed here
1003 = Explicit type arguments cannot be specified in raw constructor reference expression
# more lambda:
1004 = This lambda expression must return a result of type {0}

# Default methods:
# variant of 359: 
1050 = Illegal modifier for the interface method {0}; only public, abstract, default, static and strictfp are permitted
1051 = A default method cannot override a method from java.lang.Object 
1052 = The default method {0} inherited from {1} conflicts with another method inherited from {2}
1053 = Duplicate default methods named {0} with the parameters ({1}) and ({2}) are inherited from the types {3} and {4}
1054 = Illegal reference to super type {0}, cannot bypass the more specific direct super type {1}
1055 = Illegal reference to super method {0} from type {1}, cannot bypass the more specific override from type {2}
1056 = Illegal combination of modifiers for the interface method {0}; only one of abstract, default, or static permitted
1057 = strictfp is not permitted for abstract interface method {0}
1058 = Default methods are allowed only in interfaces.
1059 = Cannot infer type argument(s) for <{0}> {1}
1060 = Illegally placed annotation: type annotations must directly precede the simple name of the type they are meant to affect (or the [] for arrays)
1061 = The nullness annotation ''{0}'' is not applicable at this location, it must be placed directly before the nested type name.
1062 = Nullness default is redundant with a default specified for the variable {0}
1063 = Nullness default is redundant with a default specified for the field {0}

1070 = Illegal combination of modifiers for the private interface method {0}; additionally only one of static and strictfp is permitted
1071 = Illegal modifier for the interface method {0}; only public, private, abstract, default, static and strictfp are permitted

1100 = Problem detected during type inference: {0}
#1101 is already used up but deprecated
1102 = At least one of the problems in category ''{0}'' is not analysed due to a compiler option being ignored
1103 = {0} is a preview feature and disabled by default. Use --enable-preview to enable
1104 = You are using a preview language feature that may or may not be supported in a future release
1105 = The preview feature {0} is only available with source level {1} and above
1106 = Preview features enabled at an invalid source release level {0}, preview can be enabled only at source level {1}
1107 = The Java feature ''{0}'' is only available with source level {1} and above
1108 = You are using an API that is part of a preview feature and may be removed in future
# more programming problems:
1200 = Unlikely argument type {0} for {1} on a {2}
1201 = Unlikely argument type for equals(): {0} seems to be unrelated to {2}

### Autoclosable try
1251 = Duplicate resource reference {0}

# Java9 - Module declaration related
1300 = {0} cannot be resolved to a module
1301 = Duplicate requires entry: {0}
1302 = Duplicate exports entry: {0}
1303 = Duplicate uses entry: {0}
1304 = Duplicate service entry: {0}
1305 = Cycle exists in module dependencies, Module {0} requires itself via {1}
1306 = Invalid service implementation, the type {0} is abstract
1307 = The service implementation {0} must define a public static provider method or a no-arg constructor
1308 = The no-arg constructor of service implementation {0} is not public
1309 = Invalid service implementation, the type {0} is an inner class
1310 = Service implementation {0} is not defined in the module with the provides directive
1311 = The package {0} does not exist or is empty
1312 = Type {0} inferred for {1}, is not valid for an anonymous class with ''<>''
1313 = Duplicate opens entry: {0}
1314 = Duplicate module name: {0}
1315 = opens statement is not allowed, as module {0} is declared open
1316 = Invalid service interface {0}, must be a class, interface or annotation type
1317 = Invalid service implementation {0}, must be a public class or interface type
1318 = Illegal modifier for module {0}; only open is permitted
1319 = {0} cannot be resolved to a module, it is referenced from an add-reads directive
1320 = Cannot export the package {0} which belongs to module {1}

#### Java 9
1351 = Variable resource not allowed here for source level below 9

# Java 9 - advanced deprecation
1400 = The type {0} has been deprecated and marked for removal
1401 = The method {1}({2}) from the type {0} has been deprecated and marked for removal
1402 = The constructor {0}({1}) has been deprecated and marked for removal
1403 = The field {0}.{1} has been deprecated and marked for removal
1404 = The method {0} overrides a method from {1} that has been deprecated and marked for removal

1405 = The type {0} is deprecated since version {1}
1406 = The method {1}({2}) from the type {0} is deprecated since version {3}
1407 = The constructor {0}({1}) is deprecated since version {2}
1408 = The field {0}.{1} is deprecated since version {2}
1409 = The method {0} overrides a method from {1} that is deprecated since version {2}

1410 = The type {0} has been deprecated since version {1} and marked for removal
1411 = The method {1}({2}) from the type {0} has been deprecated since version {3} and marked for removal
1412 = The constructor {0}({1}) has been deprecated since version {2} and marked for removal
1413 = The field {0}.{1} has been deprecated since version {2} and marked for removal
1414 = The method {0} overrides a method from {1} that has been deprecated since version {2} and marked for removal

1425 = The package {0} is deprecated
1426 = The package {0} is deprecated since version {1}
1427 = The package {0} has been deprecated and marked for removal
1428 = The package {0} has been deprecated since version {1} and marked for removal
1429 = The module {0} is deprecated
1430 = The module {0} is deprecated since version {1}
1431 = The module {0} has been deprecated and marked for removal
1432 = The module {0} has been deprecated since version {1} and marked for removal

1450 = The type {0} is not accessible
1451 = The field {1}.{0} is not accessible
1452 = The method {1}({2}) from the type {0} is not accessible
1453 = The constructor {0}({1}) is not accessible
1454 = The package {0} is not accessible
1455 = The package {0} is accessible from more than one module: {1}
1456 = The package {0} conflicts with a package accessible from another module: {1}
1457 = The type {0} is not accessible to clients that require this module
1458 = The type {0} is not exported from this module
1459 = The type {0} from module {1} may not be accessible to clients due to missing ''requires transitive''
1460 = Must declare a named package because this compilation unit is associated to the named module ''{0}''
1461 = Name of automatic module ''{0}'' is unstable, it is derived from the module''s file name.
1462 = Type {0} is indirectly referenced from required .class files but cannot be resolved since the declaring package {1} exported from module {2} conflicts with a package accessible from module {3}

# Local-Variable Type Inference
1500 = 'var' is not allowed in a compound declaration
1501 = 'var' is not allowed as an element type of an array
1502 = Declaration using 'var' may not contain references to itself
1503 = Cannot use 'var' on variable without initializer
1504 = Cannot infer type for local variable initialized to 'null'
1505 = Variable initializer is 'void' -- cannot infer variable type
1506 = Array initializer needs an explicit target-type
1507 = Lambda expression needs an explicit target-type
1508 = Method reference needs an explicit target-type
1509 = 'var' is not a valid type name
1510 = 'var' should not be used as an type name, since it is a reserved word from source level 10 on
1511 = 'var' is not allowed here
1512 = 'var' cannot be mixed with non-var parameters

# Switch-Expressions Java 12 Preview
1600 = Incompatible switch results expressions {0}
1601 = A switch expression should have a non-empty switch block
1602 = A switch expression should have at least one result expression
1603 = A switch labeled block in a switch expression should not complete normally
1604 = The last statement of a switch block in a switch expression should not complete normally
1605 = Trailing switch labels are not allowed in a switch expression.
1606 = Mixing of different kinds of case statements '->' and  ':' is not allowed within a switch
1607 = A switch expression should have a default case
1608 = Switch expressions are allowed only at source level 12 or above
1609 = Switch Case Labels with '->' are allowed only at source level 12 or above
1610 = Break of a switch expression should have a value
1611 = A Switch expression should cover all possible values
1612 = 'continue' or 'return' cannot be the last statement in a Switch expression case body

# Switch-Expressions Java 14
1700 = Incompatible switch results expressions {0}
1701 = A switch expression should have a non-empty switch block
1702 = A switch expression should have at least one result expression
1703 = A switch labeled block in a switch expression should not complete normally
1704 = The last statement of a switch block in a switch expression should not complete normally
1705 = Trailing switch labels are not allowed in a switch expression.
1706 = Mixing of different kinds of case statements '->' and  ':' is not allowed within a switch
1707 = A switch expression should have a default case
1708 = yield of a switch expression should have a value
1709 = A Switch expression should cover all possible values
1710 = 'continue' or 'return' cannot be the last statement in a Switch expression case body
1711 = break out of switch expression not allowed
1712 = yield may be disallowed in future - qualify method calls to avoid this message
1713 = restricted identifier yield not allowed here - method calls need to be qualified
1714 = yield outside of switch expression
1715 = yield is a restricted keyword and may be disallowed in future
1716 = yield statement is illegal here
1717 = yield may be a restricted identifier in future and may be disallowed as a type name
1718 = yield is a restricted identifier and cannot be used as type name
1719 = Multi-constant case labels supported from Java 14 onwards only
1720 = Arrow in case statement supported from Java 14 onwards only
1721 = Switch Expressions are supported from Java 14 onwards only
1722 = Breaking out of switch expressions not permitted
1723 = Continue out of switch expressions not permitted
1724 = Return within switch expressions not permitted
# Java 15 Preview - begin
# Records
1730 = Illegal modifier for the record {0}; only public, private, protected, static, final and strictfp are permitted
1731 = Illegal modifier for the record {0}; only public, final and strictfp are permitted
1732 = Illegal component name {0} in record {1};
1733 = User declared non-static fields {0} are not permitted in a record
1734 = Throws clause not allowed for explicitly declared accessor method
1735 = Throws clause not allowed for canonical constructor {0}
1736 = Cannot reduce the visibility of a canonical constructor {0} from that of the record
1737 = Multiple canonical constructors {0} are not allowed
1738 = The body of a compact constructor must not contain a return statement
1739 = Duplicate component {0} in record
1740 = Illegal modifier native for method {0}; native methods are not allowed in record
1741 = Instance Initializer is not allowed in a record declaration
1742 = ''{0}'' is not a valid type name; it is a restricted identifier and not allowed as a type identifier in Java {1}
1743 = Illegal return type of accessor; should be the same as the declared type {0} of the record component
1744 = The accessor method must not be generic
1745 = The accessor method must be declared public
1746 = Canonical constructor {0} of a record declaration should not be generic
1747 = The body of a canonical constructor must not contain a return statement
1748 = The body of a canonical constructor must not contain an explicit constructor call
1749 = The body of a compact constructor must not contain an explicit constructor call
1750 = Nested Record is (implicitly) static and hence enclosing type should be static
1751 = The accessor method must not be static
1752 = The type {1} may not subclass {0} explicitly
1753 = void is an invalid type for the component {0} of a record
1754 = The variable argument type {0} of the record {1} must be the last parameter
1755 = Cannot make a static reference to the non-static variable {0}
1756 = A record declaration {0} is not allowed in a local inner class
1757 = A record component {0} cannot have modifiers
1758 = Illegal parameter name {0} in canonical constructor, expected {1}, the corresponding component name
1759 = Illegal explicit assignment of a final field {0} in compact constructor
1760 = A non-canonical constructor must start with an explicit invocation to a constructor
1761 = A local class or interface {0} is implicitly static; cannot have explicit static declaration
1762 = Illegal modifier for the local record {0}; only final and strictfp are permitted
1763 = Extended dimensions are illegal for a record component
1764 = @SafeVarargs annotation cannot be applied to record component without explicit accessor method {0}


1765 = Illegal modifier for the local interface {0}; abstract and strictfp are the only modifiers allowed explicitly 
1766 = Illegal modifier for local enum {0}; no explicit modifier is permitted
 
1780 = The pattern variable {0} is not in scope in this location
1781 = The pattern variable {0} is final and cannot be assigned again
1782 = Expression type cannot be a subtype of the Pattern type
1783 = Illegal modifier for the pattern variable {0}; only final is permitted
1784 = A pattern variable with the same name is already defined in the statement


# Java 15 Preview - cont.

# Additional doc
1800 = Missing uses tag
1801 = Duplicate uses tag
1802 = Missing uses class name
1803 = Invalid uses class name
1804 = Invalid uses class
1805 = Missing provides tag
1806 = Duplicate provides tag
1807 = Missing provides class name
1808 = Invalid provides class name
1809 = Invalid provides class
1810 = Invalid module qualification

# Java 16
1820 =  {0} is a value-based type which is a discouraged argument for the synchronized statement

# Java 15 Preview - cont
1850 = The class {1} with a sealed direct superclass or a sealed direct superinterface {0} should be declared either final, sealed, or non-sealed
1851 = A class {0} declared as non-sealed should have either a sealed direct superclass or a sealed direct superinterface
1852 = The type {0} extending a sealed class {1} should be a permitted subtype of {1}
1853 = The type {0} that {2} a sealed interface {1} should be a permitted subtype of {1}
1854 = A type declaration {0} that has a permits clause should have a sealed modifier
1855 = The interface {1} with a sealed direct superinterface {0} should be declared either sealed or non-sealed
1856 = Duplicate type {0} for the type {1} in the permits clause
1857 = Permitted class {0} does not declare {1} as direct super class
1858 = Permitted type {0} in a named module {1} should be declared in the same module {1} of declaring type {2}
1859 = Permitted type {0} in an unnamed module should be declared in the same package {1} of declaring type {2}
1860 = Sealed class or interface lacks the permits clause and no class or interface from the same compilation unit declares {0} as its direct superclass or superinterface
1861 = An interface {0} is declared both sealed and non-sealed
1862 = An interface {0} declared as non-sealed should have a sealed direct superinterface
1863 = Permitted type {0} does not declare {1} as direct super interface 
1864 = A local class {1} cannot have a sealed direct superclass or a sealed direct superinterface {0}
1865 = An anonymous class cannot subclass a sealed type {0}
1866 = Sealed type {2} and sub type {0} in an unnamed module should be declared in the same package {1}
1867 = Sealed type {1} cannot be super type of {0} as it is from a different package or split package or module

# Switch Patterns - Java 17 - JEP 406 - preview
1900 = Local variable {0} referenced from a guard must be final or effectively final
1901 = Constant case label elements and pattern case label elements cannot be present in a switch label
1902 = Illegal fall-through to a pattern
1903 = A switch label may not have more than one pattern case label element
1904 = A switch label may not have both a pattern case label element and a default case label element
1905 = A null case label and patterns can co-exist only if the pattern is a type pattern
1906 = This case label is dominated by one of the preceding case label
1907 = Switch case cannot have both a total pattern and default label
1908 = An enhanced switch statement should be exhaustive; a default label expected
1909 = The switch statement cannot have more than one total pattern
1910 = Unnecessary 'null' pattern, the switch selector expression cannot be null
1911 = Unexpected type {0}, expected class or array type

### ELABORATIONS
## Access restrictions
78592 = The type ''{1}'' is not API (restriction on classpath entry ''{0}'')
78593 = The type ''{1}'' is not API (restriction on required project ''{0}'')
78594 = The type ''{1}'' is not API (restriction on required library ''{0}'')
78596 = The field ''{2}.{1}'' is not API (restriction on classpath entry ''{0}'')
78597 = The field ''{2}.{1}'' is not API (restriction on required project ''{0}'')
78598 = The field ''{2}.{1}'' is not API (restriction on required library ''{0}'')
78600 = The constructor ''{1}'' is not API (restriction on classpath entry ''{0}'')
78601 = The constructor ''{1}'' is not API (restriction on required project ''{0}'')
78602 = The constructor ''{1}'' is not API (restriction on required library ''{0}'')
78604 = The method ''{2}.{1}'' is not API (restriction on classpath entry ''{0}'')
78606 = The method ''{2}.{1}'' is not API (restriction on required library ''{0}'')
78605 = The method ''{2}.{1}'' is not API (restriction on required project ''{0}'')
### ObjectTeams:
100001 = The type org.objectteams.Team cannot have a superclass or superinterfaces
100002 = Illegal modifier for team class {0}.

### TEAMS AND ROLES
112101 = Illegal modifier for role {0}. Roles cannot be static (OTJLD 1.2.1).
112102 = Illegal access modifier for role {0}. Only public and protected are allowed here (OTJLD 1.2.1(a)).
112103 = The method {1}({2}) from the role type {0} is not visible (OTJLD 1.2.1(e)).
112104 = The role constructor {0}({1}) is not visible (OTJLD 1.2.1(e)).
112105 = Type mismatch: cannot convert from {0} to {1} because type anchors could not be proven to be the same instance (OTJLD 1.2.2(e)).
112106 = Cannot access non-public field {0} via externalized role {1} (OTJLD 1.2.1(e)).
112107 = Cannot access non-public method {1} via externalized role {0} (OTJLD 1.2.1(e)). 
112108 = Cannot access non-public constructor {0}({1}) to instantiate externalized role (OTJLD 1.2.1(e)).
112109 = Indirect tsuper method inherited from {0} is not visible (OTJLD 1.2.1(e)).
112110 = Non-constant initialization not allowed for a static field of a role class (OTJLD 1.2.1(g)).

112200 = Cannot externalize non-public role {0} (OTJLD 1.2.2(a)).
#unused: 1102201 = 
112202 = Missing anchor (team instance) for role type {0} outside its team context (OTJLD 1.2.2(b)).
112203 = Not a valid type anchor: type {0} is not the enclosing team of role type {1} (OTJLD 1.2.2(b)).
112204 = ''{0}'' cannot be used as type anchor for an externalized role: is not a team (OTJLD 1.2.2(b)).
112205 = Cannot resolve type anchor {0} (OTJLD 1.2.2(b)).
112206 = Cannot resolve type {0}: no such role in team {1} (OTJLD 1.2.2(b)).
112207 = Path syntax for externalized role type is deprecated (OTJLD 1.2.2(b)).
112208 = Invalid qualification for role type {0}, externalized roles must be anchored to a team instance, otherwise use the simple name (OTJLD 1.2.2(b)).
112209 = Invalid externalized use of role type {0}, anchor is not final (OTJLD 1.2.2(c)).
112210 = Anchor {0} for the role type {1} is not final (OTJLD 1.2.2(c)).
112211 = Not a valid type anchor for externalized role {0}, need a final variable (OTJLD 1.2.2(c)).
112212 = Creation of a role instance outside its enclosing team must have the form ''t.new R()''\n where t is a valid type anchor according to OTJLD 1.2.2(c) and R is the simple name of a role class (OTJLD 1.2.2(h)).
112213 = Illegal qualified use of type {0}: path contains no suitable team anchor (OTJLD 1.2.2(f)).
112214 = Externalized role {0} is not allowed in this position (OTJLD 1.2.2(g)).
112215 = Cannot sub-class an externalized role type (OTJLD 1.2.2(g)).
112216 = Detected a cycle while resolve field {0}.{1} as a team anchor (OTJLD 1.2.2).
112217 = Illegal import for role type {0}: roles cannot be imported (OTJLD 1.2.2(i)).
112300 = Illegal qualified use of non-public role {0} (OTJLD 1.2.3(b)).
112301 = Illegal parameterized use of non-public role {0} (OTJLD 1.2.3(b)).

112501 = Role file must contain exactly one toplevel type (OTJLD 1.2.5(b)).
112502 = The name of role file {0} does not match the role type {1} which it defines (OTJLD 1.2.5(b)).
112503 = Package name {0} does not match the name of the enclosing package {1} for role file {2} (OTJLD 1.2.5(c)).
112504 = Package declaration {0} refers to the enclosing team of role file {1}.\nMust use a ''team package'' declaration (OTJLD 1.2.5(c)).
112505 = Enclosing team {0} not found for role file {1} (OTJLD 1.2.5(c)).
112506 = Javadoc: Missing tag for role file {0} (OTJLD 1.2.5(d)).
112507 = Javadoc: Type {0} is not a role file of this team (OTJLD 1.2.5(d)).
112508 = Javadoc: {0} cannot be resolved to a role of this team (OTJLD 1.2.5(d)).
112509 = Javadoc: {0} is an inline role, whereas the @role tag should only be used for role files (OTJLD 1.2.5(d)).
112510 = Javadoc: Illegal @role tag, type {0} is not a team (OTJLD 1.2.5(d)).
112511 = The enum type {0} illegally resides in a role file of team {1} (OTJLD 1.2.5(e)). 

113001 = Illegal ''extends'' for a regular class: superclass {0} is a team (OTJLD 1.3).
113101 = Role class {0} cannot override an interface of the same name (OTJLD 1.3.1(c)).
113102 = Role interface {0} cannot override class of the same name (OTJLD 1.3.1(c)).
113103 = Cannot override the final role {0} (OTJLD 1.3.1(c)).
113104 = Role {0} must override a role from a super team (OTJLD 1.3.1(c)).
113105 = Role {0} should be tagged with @Override since it actually overrides a superteam role (OTJLD 1.3.1(c)).
113106 = Type mismatch: cannot convert from {0} to {1} because static types of enclosing teams differs (OTJLD 1.3.1(d)).
113107 = Cannot use ''tsuper'' in method {0}, enclosing type {1} is not a role (OTJLD 1.3.1(f)).
113108 = Illegal tsuper call: role {0} has no implicit super class (OTJLD 1.3.1(f)).
113109 = Invalid qualified ''tsuper'': type {1} contains no role corresponding to {0} (OTJLD 1.3.1(f)).
113110 = Illegal tsuper call: can only invoke the method being overridden by the current method (OTJLD 1.3.1(f)).
113111 = Cannot reduce the visibility of role {0} to {1}, implicit super-role is ''{2}'' (OTJLD 1.3.1(h)).
113112 = Cannot reduce the visibility of the inherited method from implicit super class {0} (OTJLD 1.3.1(h)).
113113 = The return type of implicitly inherited method {0} is not compatible to the return type of explicitly inherited method {1} (1.3.1(k)).
113201 = Cannot extend {1}.{0} because enclosing type {1} is not an enclosing type of this role (OTJLD 1.3.2(a)).
113202 = Role inherits incompatible ''extends'' declarations: {0} is not a sub-type of {1} (''extends {1}'' is inherited is from {2}) (OTJLD 1.3.2(b)).
113203 = Illegal tsuper call. Must use a constructor of newly introduced super-class {0} (OTJLD 1.3.2(c)).
113204 = Method {0} inherited from regular super class {1} is not visible outside the role {2} (OTJLD 1.3.2(e)).

114001 = Role type {0} shadows the visible type {1} (OTJLD 1.4(a)).
114002 = Field declaration {0} conflicts with an implicitly inherited field (OTJLD 1.4(b)).

115001 = Regular role cannot override team {0} (OTJLD 1.5(a)).
115002 = Member types not allowed in regular roles. Mark class {0} as a team if {1} should be its role (OTJLD 1.5(a,b)). 
115003 = Team {0} cannot extend its enclosing team {1} (OTJLD 1.5(c)).
115004 = Name clash for implicit super types of role {0}: {1} and {2} are incomparable (OTJLD 1.5(d)).


### ROLE-BASE-BINDING
121001 = Overlapping role hierarchies: role is subtype of these bound roles: {0} (OTJLD 2.1(c)).
121002 = Illegal redefinition: {0} is not a sub-type of baseclass {1} as inherited from {2} (OTJLD 2.1(c)).
121003 = Role inherits incompatible ''playedBy'' declaration(s): {0} is not comparable to {1} (OTJLD 2.1(c)).
121004 = Cannot bind role class {0} to {1} because implicit super-role is already bound to {2} (OTJLD 2.1(d)).
121101 = When binding interface {0} as base of {1}:\nNote that some features like callin bindings are not yet supported in this situation (OTJLD 2.1.1).
121201 = Member type {0} cannot be used as the base class of {1} (OTJLD 2.1.2(b)).
121202 = Role {1} cannot be played by {0}: this name stands for a role of the same team (OTJLD 2.1.2(a)).
121203 = Base class {0} is an enclosing type of {1}; please read the hints in the OT/J Language Definition (OTJLD 2.1.2(b)).
121204 = Base class/member type circularity via chain {0};\nplease read the hints in the OT/J Language Definition (OTJLD 2.1.2(b)).
121205 = Overriding access restriction of base class {0} (OTJLD 2.1.2(c)).
121206 = PlayedBy binding overrides finalness of base class {0} (OTJLD 2.1.2(c)).
121207 = Trying to override access restriction of confined base class {0} (OTJLD 2.1.2(c)).
121208 = "base" import is not allowed in regular class {0} (OTJLD 2.1.2(d)).
121209 = "base" import is not allowed in a role file (OTJLD 2.1.2(d)).
121210 = It is recommended that base class {0} be imported with the modifier "base" (OTJLD 2.1.2(d)).
121211 = Qualified reference to base class {0} is deprecated, should use a base import instead (OTJLD 2.1.2(d)).
121212 = Bound base class {0} cannot have free type parameters (OTJLD 2.1.2(e)).
121213 = Role {0} cannot have free type parameters when binding to a base class (OTJLD 2.1.2(e)).

121299 = Base class {0} is deprecated.

121308 = Illegal base import: this package is not provided by the declared base plug-in(s) {0} (OT/Equinox).
121309 = Illegal base import: this package is not provided by the declared base plug-in {0} but by plug-in {1} (OT/Equinox).
121310 = Illegal base import: no aspect binding declared for team {0} or any nested team (OT/Equinox).
121311 = Decapsulating base class {0} by means of a forced export. Note, that additionally a corresponing declaration is needed in config.ini (OTJLD 2.1.2(c) + OT/Equinox).
121312 = This messages should never be seen ({0}).
121313 = The forced-exported type {0} cannot be accessed other than as a role's base class (OT/Equinox).
121314 = The declared base plug-in contains one or more split packages; please manually ensure that class {0} is actually provided by plug-in {1} (OT/Equinox).
121315 = A declared base plug-in contains on or more split packages; please manually ensure that class {0} is actually provided by one of the plug-ins {1} (OT/Equinox).

122001 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).
122002 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).\nPerhaps you should just remove this cast?
122003 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).\nPerhaps you should use a local variable to get the lowered expression? 
122004 = Assigning a {0} to {1} is ambiguous: will not apply lowering to {2} because direct upcasting is sufficient (OTJLD 2.2(f)).

123101 = The constructor {0} is undefined. Note that bound roles per default only have a lifting constructor (OTJLD 2.3.1(b)).
123102 = Need custom lifting constructor, because super class has no argumentless constructor {0} (OTJLD 2.3.1(c)).
123103 = Lifting constructor cannot have explicit super-call (OTJLD 2.3.1(c)).
123104 = Annotation '@{0}' can only be applied to role classes (OTJLD 2.3.1(d)).
123105 = Fields are discouraged in roles with InstantiationPolicy '{0}' (OTJLD 2.3.1(d)).
123106 = Roles with InstantiationPolicy '{0}' should define equals() and hashCode() methods (OTJLD 2.3.1(d)).
123107 = Need to invoke a tsuper constructor because tsuper role ''{0}'' has initializations for final fields.

123201 = Illegal type for argument {0}: declared lifting not allowed in static methods (OTJLD 2.3.2(a)).
123202 = Qualified type name not allowed here. Type after keyword "as" must be a role of the enclosing team {0} (OTJLD 2.3.2(a)).
123203 = Declared lifting is only allowed in signatures of team methods (OTJLD 2.3.2(a)).
123204 = The primitive type {0} is not allowed in declared lifting type (OTJLD 2.3.2(a)).
123205 = Illegal type {0}, need a role type for declared lifting (OTJLD 2.3.2(a)).
123206 = Cannot lift to role {0} because it is not played by a base class (OTJLD 2.3.2(a)).
123207 = Class {0} is incompatible to the base class {2} of role {1}. Lifting not possible (OTJLD 2.3.2(a)).
123208 = Syntax error in declared lifting. Array dimensions do not match (OTJLD 2.3.2(c)).
123209 = Illegal type bound: {0} is not a role type (OTJLD 2.3.2(e)).
123210 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} base {6}> (OTJLD 2.3.2(e)).

123401 = Potential ambiguity in role binding. The base ''{0}'' is bound to the following roles: {1} (OTJLD 2.3.4(a)).
123402 = Team introduces binding ambiguity for role {0}, which may break clients of the super team (OTJLD 2.3.5(d)).
123403 = Unhandled exception type LiftingFailedException, caused by an unsafe lifting request (OTJLD 2.3.5).

124101 = Cannot invoke the lifting constructor {0} to create an externalized role (OTJLD 2.4.1(a)).
124102 = Argument to lifting constructor {0} is not a freshly created base object (of type {1}); may cause a DuplicateRoleException at runtime (OTJLD 2.4.1(c)).
124201 = Illegal base constructor call: enclosing ''{0}'' is not a constructor of a bound role (OTJLD 2.4.2).
124202 = Illegal call to base constructor: this constructor is a lifting constructor (OTJLD 2.4.2).
124203 = Cannot use this constructor from class {0}, because it creates a base instance of type {2} wheras a base instance of type {1} is required (OTJLD 2.4.2(c)).
124204 = Constructor call (tsuper) must be the first statement in a role constructor (OTJLD 2.4.2).
124205 = Cannot invoke a base constructor because enclosing role {0} is involved in baseclass circularity (OTJLD 2.4.2). 
124206 = Call to base constructor is not first statement (after super-call) (OTJLD 2.4.2(b)).
124207 = Missing call to a base constructor, class {0} is a bound role (OTJLD 2.4.2(b)).
124208 = Illegal call to base constructor: constructor called by ''{0}'' already calls a base constructor (OTJLD 2.4.2(b)).
124209 = Access restriction of constructor {0} is overridden by this base constructor call (OTJLD 2.4.2(b)).
124210 = Base constructor call not allowed in this position, must be first statement or argument to another constructor call (OTJLD 2.4.2(c)).
124211 = This constructor conflicts with the lifting constructor (using argument lowering).\nDue to lower visibility external allocations will use the lifting constructor instead (OTJLD 2.4.2(d)).
124301 = Dangerous instantiation. To avoid a WrongRoleException at runtime role {0} should be used instead (OTJLD 2.4.3).

125001 = Team {0} may need to be declared abstract, because irrelevance for abstract role {1} could not be shown (OTJLD 2.5(b)).
125002 = Team {0} must be declared abstract, because abstract role {1} is relevant (OTJLD 2.5(b)).

126001 = Cannot use ''base'' as a prefix since ''{0}'' is not a team (OTJLD 2.6(a)).
126002 = Illegal qualified use of ''base'', type ''{0}'' is not a bound role (OTJLD 2.6(a)).
126003 = Cannot use ''base'' in the regular method ''{0}'' (OTJLD 2.6(c)).
126004 = Cannot use explicit base call in method bindings (OTJLD 2.6).
126005 = Illegal use of keyword ''base'' (OTJLD 2.6).
126006 = Access restriction of field {0} in type {1} is overridden by this reference (OTJLD 2.6(g)).
126007 = Access restriction of method {0} in type {1} is overridden by this call (OTJLD 2.6(g)).

### CALLOUT
131001 = Method binding not allowed here, {0} is not a role (OTJLD 3.1(a)).
131002 = Method binding not allowed here, role {0} is not played by a base class (OTJLD 3.1(a)).
131003 = Role {0} cannot declare callout bindings because it is playedBy enclosing type {1} (OTJLD 3.1(a)); please directly access the target method.
131004 = No method {0} found in type {1} to resolve method designator (OTJLD 3.1(c)).
131005 = Method specifier ''{0}'' is ambiguous for the type {1}. Please use the exact method signature to disambiguate (OTJLD 3.1(c)).
131006 = Method designator binds to a method returning {0} whereas return type {1} is specified (OTJLD 3.1(c)).
131007 = Method specifier finds no direct match, argument of closest match is {0} instead of {1} (OTJLD 3.1(c)).
131008 = A non-abstract role method exists for this callout-binding. Use callout-override (''=>'') if you want to override it (OTJLD 3.1(e)).
131009 = Trying to bind an abstract method as callout override (OTJLD 3.1(e)).
131010 = Callout binding tries to override method {0} from the same role class (OTJLD 3.1(e)).
131011 = Callout binding conflicts with inherited callout binding from class {0}. Use ''=>'' if you want to override it (OTJLD 3.1(f)).
131012 = The method is bound as callout more than once: {0} (OTJLD 3.1(g)).
131013 = Callout method does not declare {0} which is thrown by the bound base method (OTJLD 3.1(h)).
131014 = Inherited abstract method {0} is implicitly bound as an inferred callout (OTJLD 3.1(j)).
131015 = Unresolved self call {0} is implicitly bound by an inferred callout (OTJLD 3.1(j)).
131016 = Attempting to infer callout to base field {0} in a compound assignment (OTJLD 3.1(j)).

132001 = Unused mapping for parameter {0} is ignored (OTJLD 3.2).
132002 = Syntax error: parameter mapping allowed only if methods are specified with their signatures (OTJLD 3.2(a)).
132003 = Parameter {0} is mapped more than once (OTJLD 3.2(b)).
132004 = Incomplete parameter mapping: argument {0} of base method {1} is not mapped (OTJLD 3.2(b)).
132005 = Wrong mapping direction for parameter {0}, should use {1} unless mapping 'result' (OTJLD 3.2(b)). 
132006 = Wrong mapping direction for \"result\", should use {0} (OTJLD 3.2(c)). 
132007 = Illegal mapping for 'result'. {0} returns void (OTJLD 3.2(c)).
132008 = Illegal use of 'result' in parameter mapping: wrong binding direction (OTJLD 3.2(c)).
132009 = Cannot use 'result' here: method {0} returns void (OTJLD 3.2(c)).
132010 = ''result'' can only be mapped to ''result'' (OTJLD 3.2(c)).
132011 = Method {0} does not provide enough arguments for binding to method {1} (OTJLD 3.2(e)).
132012 = Cannot implicitly map signatures for callout binding:\nBase method {1} returns void whereas role method {0} expects {2} (OTJLD 3.2(e)).
132013 = Parameter mapping not allowed here: enclosing type {0} is an interface (OTJLD 3.2(a)).

133001 = Type mismatch in callout binding: cannot convert from {0} to {1} (OTJLD 3.3(d)).
133002 = When mapping the {0}. argument of {1}: cannot convert from {2} to {3} (OTJLD 3.3(d)).
133003 = The bound method {0} does not provide required result of type {1} (OTJLD 3.3(d)).
133004 = Callout binding:\nReturn of base method {1} is incompatible with return expected by method {0}:\nCan't convert {3} to {2} (OTJLD 3.3(d)).

134001 = This class overrides access restrictions of its base class. Compile with -decapsulation for details (OTJLD 3.4(a)).
134002 = Access restriction of method {0} in type {1} is overridden by this method binding (OTJLD 3.4(a)).
134003 = The method {0} from type {1} is not visible for this binding (enable decapsulation? OTJLD 3.4).
134004 = The private base feature {0} from type {1} is not available via the base type {2} (OTJLD 3.4(d)). 

135001 = Callout binding cannot resolve field {0} in type {1} (OTJLD 3.5).
135002 = Field specifier ''{0}'' resolves to type {1} whereas type {2} is specified (OTJLD 3.5(a)).
135003 = Accessing field {1} through method "{0}" has no effect (OTJLD 3.5(b)).
135004 = Binding method ''{0}'' via callout as field setter cannot return a value (OTJLD 3.5(b)).
135005 = Cannot bind role method {0} to field {1}:\nMissing parameter of type {2} (OTJLD 3.5(b)).
135006 = When binding field {1} via callout to role method {0}:\nIncompatible types: can't convert {3} to {2} (OTJLD 3.5(b)).
135007 = When binding role method {0} via callout to field {1}:\nIncompatible types: can't convert {3} to {2} (OTJLD 3.5(b)).
135008 = Access restriction of {2}field {0} in type {1} is overridden by this binding (OTJLD 3.5(e)).
135009 = Write access to the {2}field {0} in type {1} overrides access restriction (OTJLD 3.5(e)).
135010 = A non-abstract role method exists for this callout-binding. Use callout-override (''=>'') if you want to override it (OTJLD 3.5(g)).
135011 = Callout binding conflicts with inherited callout binding from class {0}. Use ''=>'' if you want to override it (OTJLD 3.5(g)).
135012 = Assignment to unresolved variable {0} implicitly uses callout to base field '{1}' (OTJLD 3.5(h)).
135013 = Reference {1} implicitly uses callout getter to base field '{1}' (OTJLD 3.5(h)).
135014 = Method call {0} tries to re-use an inferred callout to field (OTJLD 3.5(h)). 

### CALLIN
141001 = Method binding not allowed here, {0} is not a role (OTJLD 4.1(b)).
141002 = Method binding not allowed here, role {0} is not played by a base class (OTJLD 4.1(b)).
141003 = Unsafe callin binding, because lifting to role {0} may fail due to a reported binding ambiguity (OTJLD 2.3.5(c)).
141004 = Unsafe callin binding, because lifting to role {0} may fail due to abstractness (OTJLD 2.3.5(c)).
141005 = No method {0} found in type {1} to resolve method designator (OTJLD 4.1(c)).
141006 = Method specifier "{0}" is ambiguous for the type {1}. Please use the exact method signature to disambiguate (OTJLD 4.1(c)).
141007 = Method designator binds to a method returning {0} whereas return type {1} is specified (OTJLD 4.1(c)).
141008 = Method specifier finds no direct match, argument of closest match is {0} instead of {1} (OTJLD 4.1(c)).
141009 = Duplicate callin name "{0}" (OTJLD 4.1(e)).
141010 = Trying to bind final method {0} from class {1} via class {2}; must bind directly to {1} (OTJLD 4.1(f).
141011 = Base method does not declare {0} which is thrown by the bound role method (OTJLD 4.1(g)).
141012 = Callin binding to constructor ''{0}'' must use the callin modifier "after" (OTJLD 4.1(i)). 
141013 = Callin ''{0}'' is overridden in role ''{1}'' within the same team, will have no effect (OTJLD 4.1(e)).

141099 = Bound base method {0} is deprecated.

142001 = Modifier ''callin'' not allowed here. Enclosing class {0} is not a role (OTJLD 4.2(d)).
142002 = Illegal modifier(s) ''{0}'' for method {1}, callin method must not declare visibility (OTJLD 4.2(d)).
142003 = Method {0} cannot be called explicitly; is a callin method (OTJLD 4.2(d)).
142004 = Cannot bind method {0} as callout; is a callin method (OTJLD 4.2(d)).
142005 = Cannot bind method {0} using "replace": need a callin method (OTJLD 4.2(d)).
142006 = Cannot bind callin method {0} using "{1}" (OTJLD 4.2(d)).
142007 = Modifier "callin" not allowed here; trying to override a method from {0} which is not a callin method (OTJLD 4.2(d)). 
142008 = Missing modifier "callin"; trying to override a method from {0} which is a callin method (OTJLD 4.2(d)).
142009 = Class inherits incompatible methods {0} from {1} and {2}: conflict between callin and regular method (OTJLD 4.2(d)).

143001 = Illegal method in base call, can only call base version of the enclosing method {0} (OTJLD 4.3(a)).
143002 = Base call "{0}" does not match the signature of the enclosing callin method (OTJLD 4.3(a)).
143003 = Potentially missing base call in callin method (OTJLD 4.3(b)).
143004 = This callin method has no base call (OTJLD 4.3(b)).
143005 = Potentially duplicate base call (OTJLD 4.3(c)).
143006 = This callin method calls its base method more than once (OTJLD 4.3(c)).
143007 = Illegal callin binding: base method requires a result of type {0}, which is not provided in this binding nor by a base call in the bound role method (OTJLD 4.3(e)).
143008 = Fragile callin binding: base method requires a result of type {0}, which is not provided in this binding. If no base call is issued, the result will be missing, causing a ResultNotProvidedException to be thrown (OTJLD 4.3(e)).
143009 = Fragile callin binding: base method requires a result of type {0}, which is not provided in this binding. If no base call is issued, the result will be uninitialized (null) (OTJLD 4.3(e)).
143010 = Incompatible callin binding: callin method {1} contains a base super call but bound base method {0} is not overriding a super method (OTJLD 4.3(f)).
143011 = Base super call bypasses both the bound base method and also other callin bindings if any are bound to the same base method (OTJLD 4.3(f)).
143012 = Base call {0}({1}) is not applicable for the arguments ({2})

144000 = Syntax error: parameter mapping allowed only if methods are specified with their signatures (OTJLD 4.4(a)).
144001 = Illegal use of 'result' in parameter mapping: wrong binding direction (OTJLD 4.4(a)).
144002 = Method {1} does not provide enough arguments for binding to method {0} (OTJLD 4.4(a)).
144003 = Parameter {0} is mapped more than once (OTJLD 4.4(a)).
144004 = Cannot use 'result' here: method {0} returns void (OTJLD 4.4(a)).
144005 = Incomplete parameter mapping: argument {0} of role method {1} is not mapped (OTJLD 4.4(a)).
144006 = Callin after binding cannot return a value to the base caller, role method return value of type {0} will be ignored (OTJLD 4.4(a)).
144007 = Illegal expression in callin replace binding: here 'result' must be mapped to 'result' (OTJLD 4.4(b)).
144008 = Role method "{1} {0}" bound via replace callin to method "{4} {3}" must not return a non-void result (OTJLD 4.4(b)).
144009 = Callin binding:\nReturn of method {1} is incompatible with return expected by base method {0}:\nCan't convert {3} to {2} (OTJLD 4.4(b)).
144010 = When binding method "{1} {0}" via callin to method "{4} {3}":\nBase call would require to convert return type {5} to {2} (OTJLD 4.4(b)).
144011 = ''result'' can only be mapped to ''result'' (OTJLD 4.4(b)).
144012 = Illegal expression in callin replace binding: cannot use base method argument in compound expression (OTJLD 4.4(b)).
144013 = Illegal direction ''->'' in parameter mapping for non-replace callin (OTJLD 4.4(c)).

145001 = Type mismatch in callin binding: cannot convert from {0} to {1} (OTJLD 4.5(d)).
145002 = When mapping the {0}. argument of {1}: cannot convert from {2} to {3} (OTJLD 4.5(d)).
# unused:
145003 = The bound method {0} does not provide required result of type {1} (OTJLD 4.5(d)).
145004 = When mapping the {2}. argument: types {0} and {1} are not two-way compatible as required for replace bindings (OTJLD 4.5(d)).

146001 = Access restriction of method {0} in type {1} will be overridden if the bound callin method issues a base call (OTJLD 4.6).
146002 = The private base feature {0} from type {1} is not available via the base type {2} (OTJLD 4.6(a)). 


147001 = Cannot bind static base method {1} to non-static role method {0} (OTJLD 4.7(b)).
147002 = Cannot bind non-static base method {1} to static callin method {0} via replace (OTJLD 4.7(d)).

148001 = ''{4}'' callin bindings {0}.{1} and {2}.{3} refer to the same base method; must declare precedence of these bindings (OTJLD 4.8).
148002 = 'precedence' declaration can only refer to direct role classes, however {1} is a nested role of team {0} (OTJLD 4.8).
148003 = 'precedence' declaration not allowed here, enclosing type {0} is neither a team nor a role (OTJLD 4.8(a)).
148004 = 'precedence' declaration for 'after' binding must be specified as 'precedence after' (OTJLD 4.8(a)).
148005 = 'precedence after' declaration cannot refer to '{0}' bindings (OTJLD 4.8(a)).
148006 = Callin binding {0} not found in type {1} (OTJLD 4.8(b)).
148007 = Type {0} is not a legal prefix for callin {1}; Need a role or team type (OTJLD 4.8(b)).
148008 = Contradictory precedence lists for type {0} cannot be combined (conflicts with ''{1}'') (OTJLD 4.8(d)).
148009 = Contradictory precedence lists for type {0} cannot be combined (''{1}'' vs. ''{2}'') (OTJLD 4.8(d)).
148010 = Cannot define precedence for '{0}' and '{1}', because the former overrides the latter (OTJLD 4.8(e)).

149001 = This callin binding admits covariant base method return types, must use a fresh type variable like "<E extends {0}> E" as the role side return type (OTJLD 4.9.3(c)).

149501 = Type variable {0} cannot capture a covariant return type because it is used more than once in this signature (OTJLD 4.10(a)). 

### ACTIVATION/PREDICATES
152001 = Within statement {0} must have a team instance as argument (OTJLD 5.2(a)).
154001 = Guard predicate throws checked exception {0} (OTJLD 5.4(c)).
154101 = ''{0}'' cannot be resolved, perhaps you need to add signatures to the callin binding in order to expose parameters/result? (OTJLD 5.4.1(a)).
154201 = Illegal base guard: {0} is not a bound role (OTJLD 5.4.2(f)).

### API
161001 = Cannot use class literal for role {0} in a static context (OTJLD 6.1(c)).
161002 = Cannot use unqualified class literal for role {0} outside its enclosing team (OTJLD 6.1(c)).
162001 = The method {0} conflicts with a predefined method of same name and number of arguments (OTJLD 6.2).

### ENCAPSULATION
172001 = Role class tries to override the builtin type org.objectteams.Team.{0} (OTJLD 7.2(a)).
172002 = An array of confined roles is not compatible with java.lang.Object (OTJLD 7.2(b)).

### DEPENDENT TYPES
190210 = Parameter is not a value (OTJLD 9.2.1).
190211 = Parameter cannot be resolved to an object reference (OTJLD 9.2.1).
190212 = Parameter '{0}' cannot be resolved (OTJLD 9.2.1).
190213 = Parameter does not match declaration of value parameter '{0} {1}' (OTJLD 9.2.1).
190214 = Illegal use of value parameter: type {0} does not declare a value parameter at position {1} (OTJLD 9.2.1).
190215 = Cannot rebind the anchor {1} of type variable {0} (OTJLD 9.2.1(a)).

190220 = Bound mismatch: The type {0} is not a valid substitute for the value dependent parameter <{2}> of the type {1} (OTJLD 9.2.2)

### SYNTAX
200101 = Object Teams keyword not enabled in this scope (OTJLD A.0.1).
200201 = Illegal superclass: Name of method ''{0}'' inherited from {1} is a keyword in OT/J (OTJLD A.0.2).
200301 = Illegal identifier {0} (OTJLD A.0.3).

201101 = Illegal ''playedBy'' declaration: class {0} is not a role (OTJLD A.1.1(a)).

203101 = Method binding must be directly contained in a class (OTJLD A.3.1).
203201 = Modifiers not allowed in short callout bindings (OTJLD A.3.2).
203202 = Illegal modifier for callout binding (only public, protected or private allowed here) (OTJLD A.3.2).
203203 = Illegal method designator: illegal constructor reference or missing return type (OTJLD A.3.2). 
203204 = Syntax error: missing return type for method designator (OTJLD A.3.2). 
203301 = Modifiers not allowed in callin bindings (OTJLD A.3.3).
203302 = Syntax error: callin label must be a simple name (OTJLD A.3.3).
203303 = Callin modifier (before, after or replace) missing for callin-binding {0} (OTJLD A.3.3).
203304 = Syntax error: right hand side of method binding does not specify type arguments (OTJLD A.3.3).
203305 = Syntax error: callin annotations must be specified after the callin name (OTJLD A.3.3).

203501 = Method designator must not specify a modifier (OTJLD A.3.5). 

206001 = Syntax Error: Declared lifting type not support in this position (OTJLD A.6(a)).

207001 = Syntax Error: missing boolean expression for guard predicate (OTJLD A.7.1).

209001 = Illegal position for value parameter {0}: must be a parameter of a single name type reference(OTJLD A.9(a)).

209501 = Syntax error, SingleTypeReference expected (OTJLD 1.2.4(c)).


### LIMITATIONS
210001 = Limitation: generics not supported in this position.
210002 = Internal method for lifting type {0} to role {1} has not been generated.
210003 = Compiler limitation: This constructor seems to request lifting of an argument. However, the self call in {0} of class {1} passes its arguments in an unexpected way. Cannot perform required transitive byte-code translation.
210006 = Requesting role file {0} for team {1} which is already compiled (compiler limitation).
210007 = Role {0} is missing for binary team {1} (compiler limitation).
210008 = Role {0} has not been copied (implicit inheritance) to team {1} (probably caused by some other error).
210009 = Cannot generate method {0}, tsuper method has corrupt byte code. This may or may not be caused by an internal compiler error.
210010 = Implicit super role has incompatible byte code, offending name: ''{0}''. It was probably compiled for an incompatible JRE.
210011 = Limitation: compiler support for dependent types is incomplete: {0}.
210012 = Using an experimental feature: {0}.
210013 = Role {0} seems to refer to a stale tsuper role {1}: tsuper method {2} cannot be resolved. Please consider a full rebuild of the enclosing project.
210014 = Role {1} seems to require recompilation due to changes in super role {0}. Please consider a full rebuild of the enclosing project.
210015 = A synthetic access method for field {1} is missing in type {0}. Please consider a full rebuild of the enclosing project.
210016 = Compiler limitation: wrong compilation order for role {0} as a member of team {1} which is already compiled.
210017 = Incremental compilation problem: role {0} consists of a source and a binary part. 
210018 = Internal representations of role {0} and {1} are inconsistent.
210019 = Compiler limitation: unsupported compilation order: ''{0}''.
210020 = Incomplete incremental build: did not generate callin binding for role {0}.\nBefore launching the application please perform a full build.
210021 = Cannot resolve base class for type {0}: unexpected build order (please consider a full build for this project).
210022 = Compiler limitation: the role field {0} can only be static if it is also declared final.
210023 = Illegally copied default constructor, role {0} is a bound role.
210024 = Modifier "readonly" is not yet supported.
210025 = Missing compiler implementation: {0} is not yet supported.
210026 = Base class {0} appears to be a system class, which means that load time weaving could possibly fail\nif this class is loaded from rt.jar/the bootstrap classpath.
210027 = Dangerous callin binding: {0} is used internally during lifting, which could create infinite recursion.
210028 = Compiler limitation: can't copy annotation ''{0}'' for implicitly inherited field ''{1}'': unexpected structure.
210029 = Class file {0} has incompatible OT/J byte code version {1}, please consider a full build of the declaring project.
210030 = Implementation limitation: Callin binding to an interface ({0}) is not supported.
210031 = Corrupt byte code: attempt to invoke abstract method {0}.
210032 = Role file {0} lacks a team package declaration, is this file on its project's classpath? 
210033 = Base class {0} has class file version {1} which cannot be handled by the traditional OTRE based on BCEL. Please consider using the ASM based OTDRE instead.
210034 = Class file {0} has been compiled for incompatible weaving target '{1}', please consider a full build of the declaring project.

## EXPERIMENTAL
220001 = Type {0} does not support team migration, only applicable for roles (OT/J experimental feature).
220002 = Team migration not possible because enclosing team class {0} is not final (OT/J experimental feature). 
220003 = Argument is not a valid new team anchor (OT/J experimental feature).
220004 = The special method {1}.migrateToTeam({2}) is not applicable for the arguments ({0}).
220005 = Team migration not possible in the current implementation because {0} is a bound role class (OT/J experimental feature).

220010 = Type {0} does not support base migration; this is only applicable for roles (OT/J experimental feature).
220011 = Role {0} cannot support base migration because it is not bound to a base class (OT/J experimental feature).
220012 = The special method {1}.migrateToBase({2}) is not applicable for the arguments ({0}). 

