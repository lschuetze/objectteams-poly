###############################################################################
# Copyright (c) 2000, 2010 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
# $Id: messages.properties 23306 2010-01-23 13:45:42Z stephan $
# 
# Contributors:
#     IBM Corporation - initial API and implementation
#		Benjamin Muskalla - Contribution for bug 239066
#     Fraunhofer FIRST - extended API and implementation
#     Technical University Berlin - extended API and implementation
###############################################################################
0 = {0}
1 = super cannot be used in java.lang.Object
2 = {0} cannot be resolved to a type
3 = The type {0} is not visible
4 = The type {0} is ambiguous
5 = The type {0} is deprecated
6 = The nested type {0} cannot be referenced using its binary name
7 = The type {0} is never used locally

15 = Incompatible operand types {0} and {1}
16 = Incompatible conditional operand types {0} and {1}
17 = Type mismatch: cannot convert from {0} to {1}
18 = The static member type {0}.{1} should be accessed directly

20 = No enclosing instance of type {0} is accessible to invoke the super constructor. Must define a constructor and explicitly qualify its super constructor invocation with an instance of {0} (e.g. x.super() where x is an instance of {0}).
21 = No enclosing instance of type {0} is accessible. Must qualify the allocation with an enclosing instance of type {0} (e.g. x.new A() where x is an instance of {0}).
22 = No enclosing instance of the type {0} is accessible in scope
23 = Illegal enclosing instance specification for type {0}
24 = Cannot define static initializer in inner type {0}
25 = Cannot refer to a non-final variable {0} inside an inner class defined in a different method
26 = The member interface {0} can only be defined inside a top-level class or interface
27 = Cannot use an expression of the type {0} as a valid enclosing instance
28 = No enclosing instance of type {0} is available due to some intermediate constructor invocation
29 = An anonymous class cannot subclass the final class {0}
30 = The member annotation {0} can only be defined inside a static context
31 = The member enum {0} cannot be local
32 = The member enum {0} must be defined inside a static member type
33 = The type {0} is hiding the type {1}

50 = {0} cannot be resolved
51 = The local variable {0} may not have been initialized
52 = void is an invalid type for the variable {0}
###[obsolete] 53 = An array of void is an invalid type for the variable {0}
54 = void[] is an invalid type
55 = Duplicate local variable {0}
56 = Duplicate parameter {0}
57 = The final local variable {0} may already have been assigned
58 = The final local variable {0} cannot be assigned. It must be blank and not using a compound assignment
59 = The parameter {0} should not be assigned
60 = The final local variable {0} cannot be assigned, since it is defined in an enclosing type
61 = The local variable {0} is never read
62 = The parameter {0} is never read
63 = The code of method {0}({1}) is exceeding the 65535 bytes limit
64 = The code for the static initializer is exceeding the 65535 bytes limit
65 = Too many parameters, parameter {0} is exceeding the limit of 255 words eligible for method parameters
66 = Too many local variables, local variable {0} is exceeding the limit of 65535 words eligible for method local variables
67 = Too many synthetic parameters, emulated parameter {0} is exceeding the limit of 255 words eligible for method parameters
68 = Too many array dimensions. Maximum is 255
69 = The code of constructor {0}({1}) is exceeding the 65535 bytes limit
70 = {0} cannot be resolved or is not a field
71 = The field {1}.{0} is not visible
72 = The field {0} is ambiguous
73 = The field {0}.{1} is deprecated
74 = Cannot make a static reference to the non-static field {0}
75 = Cannot reference a field before it is defined
76 = The static field {0}.{1} should be accessed in a static way
77 = The field {0}.{1} is never read locally
78 = The static field {0}.{1} should be accessed directly
79 = Unqualified access to the field {0}.{1} 
80 = The final field {0}.{1} cannot be assigned
81 = The blank final field {0} may not have been initialized
82 = The final field {0} may already have been assigned
83 = {0} cannot be resolved to a variable

90 = The local variable {0} is hiding another local variable defined in an enclosing type scope
91 = The local variable {0} is hiding a field from type {1}
92 = The field {0}.{1} is hiding another local variable defined in an enclosing type scope
93 = The field {0}.{1} is hiding a field from type {2}
94 = The parameter {0} is hiding another local variable defined in an enclosing type scope
95 = The parameter {0} is hiding a field from type {1}
96 = The serializable class {0} does not declare a static final serialVersionUID field of type long

100 = The method {1}({2}) is undefined for the type {0}
101 = The method {1}({2}) from the type {0} is not visible
102 = The method {1}({2}) is ambiguous for the type {0}
103 = The method {1}({2}) from the type {0} is deprecated
104 = Cannot directly invoke the abstract method {1}({2}) for the type {0}
105 = Void methods cannot return a value
106 = Cannot return a void result
107 = This method requires a body instead of a semicolon
108 = This method must return a result of type {0}

110 = This method has a constructor name
111 = Return type for the method is missing
112 = Native methods do not specify a body
113 = Abstract methods do not specify a body
114 = Cannot invoke {1}({2}) on the primitive type {0}
115 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
116 = Cannot invoke {1}({2}) on the array type {0}
117 = The static method {1}({2}) from the type {0} should be accessed in a static way
118 = The method {1}({2}) from the type {0} is never used locally
119 = The static method {1}({2}) from the type {0} should be accessed directly 
120 = The method {1}({2}) from the type {0} refers to the missing type {3}

129 = The constructor {0}({1}) refers to the missing type {2}
130 = The constructor {0}({1}) is undefined
131 = The constructor {0}({1}) is not visible
132 = The constructor {0}({1}) is ambiguous
133 = The constructor {0}({1}) is deprecated
134 = The constructor {0}({1}) is never used locally
135 = Cannot refer to an instance field {0} while explicitly invoking a constructor
136 = Cannot refer to an instance method while explicitly invoking a constructor
137 = Recursive constructor invocation {0}({1})
138 = Cannot refer to 'this' nor 'super' while explicitly invoking a constructor
139 = Constructor call must be the first statement in a constructor
140 = Implicit super constructor {0}({1}) is undefined for default constructor. Must define an explicit constructor
141 = Implicit super constructor {0}({1}) is not visible for default constructor. Must define an explicit constructor
142 = Implicit super constructor {0}({1}) is ambiguous for default constructor. Must define an explicit constructor
143 = Implicit super constructor {0}({1}) is undefined. Must explicitly invoke another constructor
144 = Implicit super constructor {0}({1}) is not visible. Must explicitly invoke another constructor
145 = Implicit super constructor {0}({1}) is ambiguous. Must explicitly invoke another constructor
146 = Default constructor cannot handle exception type {0} thrown by implicit super constructor. Must define an explicit constructor
147 = Unhandled exception type {0} thrown by implicit super constructor


148 = The allocated object is never used
149 = Dead code
150 = The type of the expression must be an array type but it resolved to {0}
151 = Must explicitly convert the char[] to a String
152 = String constant is exceeding the limit of 65535 bytes of UTF8 encoding
153 = case expressions must be constant expressions
154 = The literal {1} of type {0} is out of range 
156 = Cannot cast from {0} to {1}
157 = Cannot instantiate the type {0}
158 = Cannot define dimension expressions when an array initializer is provided
159 = Variable must provide either dimension expressions or an array initializer
160 = The operator {0} is undefined for the argument type(s) {1}
161 = Unreachable code
162 = Cannot return from within an initializer
163 = Initializer does not complete normally
164 = Expression must return a value
165 = Unreachable catch block for {0}. Only more specific exceptions are thrown and handled by previous catch block(s).
166 = The default case is already defined
167 = Unreachable catch block for {0}. This exception is never thrown from the try statement body
168 = Unhandled exception type {0}
169 = Cannot switch on a value of type {0}. Only convertible int values or enum constants are permitted
170 = Duplicate case
171 = Duplicate label {0}
172 = break cannot be used outside of a loop or a switch
173 = continue cannot be used outside of a loop
174 = The label {0} is missing
175 = {0} is not a valid type''s argument for the synchronized statement
176 = null is not a valid argument for the synchronized statement
177 = Cannot throw null as an exception
178 = The assignment to variable {0} has no effect
179 = Possible accidental assignment in place of a comparison. A condition expression should not be reduced to an assignment
180 = Unnecessary semicolon
181 = Unnecessary cast from {0} to {1}
182 = Unnecessary cast from {0} to {1}. It is already compatible with the argument type {2}
183 = The expression of type {0} is already an instance of type {1}
184 = finally block does not complete normally
185 = The declared exception {3} is not actually thrown by the method {1}({2}) from type {0}
186 = The declared exception {2} is not actually thrown by the constructor {0}({1})
187 = Unreachable catch block for {0}. It is already handled by the catch block for {1}
188 = Empty control-flow statement
189 = Statement unnecessarily nested within else clause. The corresponding then clause does not complete normally
190 = Read access to enclosing field {0}.{1} is emulated by a synthetic accessor method
191 = Write access to enclosing field {0}.{1} is emulated by a synthetic accessor method
192 = Access to enclosing method {1}({2}) from the type {0} is emulated by a synthetic accessor method
193 = Access to enclosing constructor {0}({1}) is emulated by a synthetic accessor method
194 = Switch case may be entered by falling through previous case. If intended, add a new comment //$FALL-THROUGH$ on the line above
195 = The method {1} is defined in an inherited type and an enclosing scope
196 = The field {0} is defined in an inherited type and an enclosing scope 
197 = The type {0} is defined in an inherited type and an enclosing scope
198 = Cannot allocate the member type {0} using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type
199 = The label {0} is never explicitly referenced
200 = Cannot use {0} in a static context
201 = Cannot make a static reference to the non-static method {1}({2}) from the type {0}
202 = Cannot specify an array dimension after an empty dimension
203 = Invalid cast expression
204 = Syntax error on token "{0}", {1} expected
205 = Syntax error on token "{0}", no accurate correction available
206 = Invalid argument to operation ++/--
207 = Interfaces cannot have constructors
208 = Array constants can only be used in initializers
209 = Syntax error on keyword "{0}"; {1} expected
210 = Syntax error on keyword "{0}", no accurate correction available
211 = Comparing identical expressions

220 = Unmatched bracket
221 = The primitive type {0} of {1} does not have a field {2}
222 = Invalid expression as statement
223 = The left-hand side of an assignment must be a variable
224 = Missing semicolon
225 = Invalid parenthesized expression

230 = Syntax error on token "{0}", {1} expected before this token
231 = Syntax error on token "{0}", {1} expected after this token
232 = Syntax error on token "{0}", delete this token
233 = Syntax error on tokens, delete these tokens
234 = Syntax error on tokens, they can be merged to form {0}
235 = Syntax error on token "{0}", invalid {1}
236 = Syntax error on token(s), misplaced construct(s)
237 = Syntax error on tokens, {0} expected instead
238 = Syntax error on tokens, no accurate correction available
239 = Syntax error, unexpected {0}
240 = Syntax error, insert "{0}" to complete {1}
241 = Syntax error, insert "{0}" to complete scope
242 = Syntax error, insert "{0}" to complete phrase

250 = Unexpected end of file
251 = Invalid hex literal number
252 = Invalid octal literal number
253 = Invalid character constant
254 = Invalid escape sequence (valid ones are  \\b  \\t  \\n  \\f  \\r  \\"  \\'  \\\\ )
255 = Invalid input
256 = Invalid unicode
257 = Invalid float literal number
258 = Null source string
259 = String literal is not properly closed by a double-quote
260 = Unexpected end of comment
261 = Non-externalized string literal; it should be followed by //$NON-NLS-<n>$
262 = Invalid digit (valid ones are 0..9)
263 = Invalid low surrogate: must be within 0xDC00 and 0xDFFF
264 = Invalid high surrogate: must be within 0xD800 and 0xDBFF
265 = Unnecessary $NON-NLS$ tag

280 = Discouraged access: {0}

300 = The interface {0} cannot define an initializer
301 = Duplicate modifier for the type {0}
302 = Illegal modifier for the class {0}; only public, abstract & final are permitted
303 = Illegal modifier for the interface {0}; only public & abstract are permitted
304 = Illegal modifier for the member class {0}; only public, protected, private, static, abstract & final are permitted
305 = Illegal modifier for the member interface {0}; only public, protected, private, static & abstract are permitted
306 = Illegal modifier for the local class {0}; only abstract or final is permitted
307 = Access restriction: {0}
308 = The class {0} can be either abstract or final, not both
309 = The interface member type {0} can only be public
310 = The member type {0} can only set one of public / protected / private
311 = The member type {0} cannot be declared static; static types can only be declared in static or top level types
312 = The type {0} cannot be the superclass of {1}; a superclass must be a class
313 = The type {1} cannot subclass the final class {0}
314 = Duplicate interface {0} for the type {1}
315 = The type {0} cannot be a superinterface of {1}; a superinterface must be an interface
316 = Cycle detected: the type {0} cannot extend/implement itself or one of its own member types
317 = Cycle detected: a cycle exists in the type hierarchy between {0} and {1}
318 = The nested type {0} cannot hide an enclosing type
319 = Duplicate nested type {0}
320 = No exception of type {0} can be thrown; an exception type must be a subclass of Throwable
321 = The package {0} collides with a type
322 = The type {1} collides with a package
323 = The type {1} is already defined
324 = The type {0} cannot be resolved. It is indirectly referenced from required .class files
325 = The public type {1} must be defined in its own file
326 = A package must be specified in {0} or a default package created
327 = The hierarchy of the type {0} is inconsistent
328 = The declared package "{1}" does not match the expected package "{0}"
329 = The type java.lang.Object cannot have a superclass or superinterfaces
330 = The type java.lang.Object must be a class
331 = Redundant superinterface {0} for the type {1}, already defined by {2}
332 = The type {0} should also implement hashCode() since it overrides Object.equals()
333 = The type {0} must be an abstract class to define abstract methods

###[obsolete] 330 = {0} cannot be resolved or is not a valid superclass
###[obsolete] 331 = Superclass {0} is not visible
###[obsolete] 332 = Superclass {0} is ambiguous
###[obsolete] 333 = Superclass {0} cannot be referenced using its binary name
###[obsolete] 334 = Superclass {0} is defined in an inherited type and an enclosing scope
###[obsolete] 335 = {0} cannot be resolved or is not a valid superinterface
###[obsolete] 336 = Superinterface {0} is not visible
###[obsolete] 337 = Superinterface {0} is ambiguous
###[obsolete] 338 = Superinterface {0} cannot be referenced using its binary name
###[obsolete] 339 = Superinterface {0} is defined in an inherited type and an enclosing scope

340 = Duplicate field {0}.{1}
341 = Duplicate modifier for the field {0}
342 = Illegal modifier for the field {0}; only public, protected, private, static, final, transient & volatile are permitted
343 = Illegal modifier for the interface field {0}.{1}; only public, static & final are permitted
344 = The field {0} can only set one of public / protected / private
345 = The field {0} can be either final or volatile, not both
346 = The field {0} cannot be declared static; static fields can only be declared in static or top level types

###[obsolete] 350 = {2} cannot be resolved (or is not a valid type) for the field {1}.{0}
###[obsolete] 351 = The type {2} is not visible for the field {1}.{0}
###[obsolete] 352 = The type {2} is ambiguous for the field {1}.{0}
###[obsolete] 353 = The field type {2} cannot be referenced using its binary name
###[obsolete] 354 = The field type {2} is defined in an inherited type and an enclosing scope

355 = Duplicate method {0}({2}) in type {1}
356 = Illegal modifier for parameter {0}; only final is permitted
357 = Duplicate modifier for the method {1} in type {0}
358 = Illegal modifier for the method {0}; only public, protected, private, static, final, abstract, synchronized & native are permitted
359 = Illegal modifier for the interface method {0}; only public & abstract are permitted
360 = The method {1} in type {0} can only set one of public / protected / private
361 = The method {1} cannot be declared static; static methods can only be declared in a static or top level type
362 = The abstract method {1} in type {0} can only set a visibility modifier, one of public or protected
363 = The abstract method {1} in type {0} can only be defined by an abstract class
364 = void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 365 = An array of void is an invalid type for the parameter {1} of the method {0}
###[obsolete] 366 = An array of void is an invalid return type for the method {0}
367 = The native method {1} cannot also be declared strictfp
368 = Duplicate modifier for parameter {0}
369 = Illegal modifier for the constructor in type {0}; only public, protected & private are permitted

###[obsolete] 370 = {2} cannot be resolved (or is not a valid type) for the parameter {1} of the method {0}
###[obsolete] 371 = The type {2} is not visible for the parameter {1} of the method {0}
###[obsolete] 372 = The type {2} is ambiguous for the parameter {1} of the method {0}
###[obsolete] 373 = The parameter type {2} cannot be referenced using its binary name
###[obsolete] 374 = The parameter type {2} is defined in an inherited type and an enclosing scope
###[obsolete] 375 = {1} cannot be resolved (or is not an exception type) for the method {0}
###[obsolete] 376 = The exception type {1} is not visible for the method {0}
###[obsolete] 377 = The exception type {1} is ambiguous for the method {0}
###[obsolete] 378 = The exception type {1} cannot be referenced using its binary name
###[obsolete] 379 = The exception type {1} is defined in an inherited type and an enclosing scope
###[obsolete] 380 = {1} cannot be resolved (or is not a valid return type) for the method {0}
###[obsolete] 381 = The return type {1} is not visible for the method {0}
###[obsolete] 382 = The return type {1} is ambiguous for the method {0}
###[obsolete] 383 = The return type {1} cannot be referenced using its binary name
###[obsolete] 384 = The return type {1} is defined in an inherited type and an enclosing scope

385 = The import {0} conflicts with a type defined in the same file
386 = The import {0} collides with another import statement
387 = Only a type can be imported. {0} resolves to a package
388 = The import {0} is never used
390 = The import {0} cannot be resolved

###[obsolete] 391 = The imported type {0} is not visible
###[obsolete] 392 = The imported type {0} is ambiguous
###[obsolete] 393 = The imported type {0} cannot be referenced using its binary name
###[obsolete] 394 = The imported type {0} is defined in an inherited type and an enclosing scope

391 = The static import {0} must be a field or member type

395 = Duplicate modifier for the variable {0}
396 = Illegal modifier for the variable {0}; only final is permitted
###[obsolete] 397 = Redundant null check: The variable {0} cannot be null at this location
###[obsolete] 398 = Null pointer access: The variable {0} can only be null at this location
###[obsolete] 399 = Potential null pointer access: The variable {0} may be null at this location
	
400 = The type {3} must implement the inherited abstract method {2}.{0}({1})
401 = Cannot override the final method from {0}
402 = Exception {0} is not compatible with throws clause in {1}
403 = Exception {0} in throws clause of {1} is not compatible with {2}
404 = The return type is incompatible with {0}
405 = The inherited method {0} cannot hide the public abstract method in {1}
406 = This instance method cannot override the static method from {0}
407 = This static method cannot hide the instance method from {0}
408 = The static method {0} conflicts with the abstract method in {1}
409 = Cannot reduce the visibility of the inherited method from {0}
410 = The method {0} does not override the inherited method from {1} since it is private to a different package
411 = This class must implement the inherited abstract method {1}, but cannot override it since it is not visible from {0}. Either make the type abstract or make the inherited method visible
412 = The method {0} overrides a deprecated method from {1}
413 = The return type is incompatible with {0}, thus this interface cannot be implemented
414 = Exception {0} is not compatible with throws clause in {1}, thus this interface cannot be implemented
415 = The variable argument type {0} of the method {1} must be the last parameter
416 = The method {0} is overriding a method without making a super invocation
417 = The method {0}.{1}({2}) is overriding a synchronized method without being synchronized
418 = The type {3} must implement the inherited abstract method {2}.{0}({1}) to override {6}.{4}({5})
419 = The return types are incompatible for the inherited methods {0}

420 = Code snippet support cannot find the class {0}
421 = Code snippet support cannot find the method {0}.{1}({2}) 
422 = super cannot be used in the code snippet code

430 = Too many constants, the constant pool for {0} would exceed 65536 entries
431 = The type generates a string that requires more than 65535 bytes to encode in Utf8 format in the constant pool

432 = Too many fields for type {0}. Maximum is 65535
433 = Too many methods for type {0}. Maximum is 65535

440 = 'assert' should not be used as an identifier, since it is a reserved keyword from source level 1.4 on
441 = 'enum' should not be used as an identifier, since it is a reserved keyword from source level 1.5 on
442 = Enum constants cannot be surrounded by parenthesis

450 = {0} {1}

451 = Null pointer access: The variable {0} can only be null at this location
452 = Potential null pointer access: The variable {0} may be null at this location
453 = Redundant null check: The variable {0} can only be null at this location
454 = Null comparison always yields false: The variable {0} can only be null at this location
455 = Redundant assignment: The variable {0} can only be null at this location
456 = instanceof always yields false: The variable {0} can only be null at this location
457 = Redundant null check: The variable {0} cannot be null at this location
458 = Null comparison always yields false: The variable {0} cannot be null at this location

460 = Empty block should be documented

### DOC
462 = Invalid URL reference. Double quote the reference or use the href syntax
463 = Description expected after this reference
464 = Unexpected duplicated tag @{0}
465 = ''{0}'' visibility for malformed doc comments hides this ''{1}'' reference
466 = Invalid member type qualification
467 = Missing identifier
468 = Cannot make a static reference to the non-static type variable {0}
469 = Invalid param tag type parameter name
470 = Unexpected tag
471 = Missing tag for parameter {0}
472 = Missing parameter name
473 = Duplicate tag for parameter
474 = Parameter {0} is not declared
475 = Missing tag for return type
476 = Duplicate tag for return type
477 = Missing tag for declared exception {0}
478 = Missing class name
479 = Invalid class name
480 = Duplicate tag for thrown exception
481 = Exception {0} is not declared
482 = Missing reference
483 = Invalid reference
484 = Malformed link reference
485 = Invalid parameters declaration
486 = Missing comment for {0} declaration
487 = Invalid tag
488 = {0} cannot be resolved or is not a field
489 = The field {0} is not visible
490 = The field {0} is ambiguous
491 = The field {0}.{1} is deprecated
492 = The constructor {0}({1}) is undefined
493 = The constructor {0}({1}) is not visible
494 = The constructor {0}({1}) is ambiguous
495 = The constructor {0}({1}) is deprecated
496 = The method {1}({2}) is undefined for the type {0}
497 = The method {1}({2}) from the type {0} is not visible
498 = The method {1}({2}) is ambiguous for the type {0}
499 = The method {1}({2}) from the type {0} is deprecated
500 = Cannot invoke {1}({2}) on the primitive type {0}
501 = The method {1}({2}) in the type {0} is not applicable for the arguments ({3})
502 = Cannot invoke {1}({2}) on the array type {0}
503 = {0} cannot be resolved to a type
504 = The type {0} is not visible
505 = The type {0} is ambiguous
506 = The type {0} is deprecated
507 = The nested type {0} cannot be referenced using its binary name
508 = The method {1} is defined in an inherited type and an enclosing scope
509 = The field {0} is defined in an inherited type and an enclosing scope 
510 = The type {0} is defined in an inherited type and an enclosing scope
511 = {0} is an ambiguous method reference or is not a field
512 = Missing closing brace for inline tag
513 = Malformed reference (missing end space separator)
514 = Javadoc: 
515 = Missing #: "{0}"
516 = Description expected after @{0}
517 = Only static field reference is allowed for @value tag
518 = Unexpected text
519 = Invalid param tag name

### GENERICS
520 = Duplicate type parameter {0}
521 = Cannot refer to the type parameter {0} as a supertype
522 = Cannot make a static reference to the non-static type {0}
523 = The type java.lang.Object cannot be declared as a generic
524 = The type {0} is not generic; it cannot be parameterized with arguments <{1}>
525 = Incorrect number of arguments for type {0}; it cannot be parameterized with arguments <{1}>
526 = Bound mismatch: The type {0} is not a valid substitute for the bounded parameter <{2} extends {3}> of the type {1}
527 = Method {0}({2}) has the same erasure {0}({3}) as another method in type {1}
528 = Illegal forward reference to type parameter {0}
529 = The type {0} is not an interface; it cannot be specified as a bounded parameter
530 = Type safety: The constructor {0}({1}) belongs to the raw type {0}. References to generic type {2} should be parameterized
531 = Type safety: The method {0}({1}) belongs to the raw type {2}. References to generic type {3} should be parameterized
532 = Type safety: The expression of type {0} needs unchecked conversion to conform to {1}
533 = Cannot use the type parameter {0} in a catch block
534 = Cannot use the parameterized type {0} either in catch block or throws clause
535 = Cannot create a generic array of {0}
536 = Type safety: The field {1} from the raw type {2} is assigned a value of type {0}. References to generic type {3} should be parameterized
537 = The type parameter {0} should not be bounded by the final type {1}. Final types cannot be further extended
538 = Inconsistent classfile encountered: The undefined type parameter {0} is referenced from within {1}
539 = The interface {2} cannot be implemented more than once with different arguments: {0} and {1}
540 = Bound mismatch: The constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
541 = Bound mismatch: The method {0}({1}) of type {2} is not applicable for the arguments ({3}). The wildcard parameter {5} has no lower bound, and may actually be more restrictive than argument {4}
542 = Bound mismatch: Cannot assign expression of type {0} to wildcard type {1}. The wildcard type has no lower bound, and may actually be more restrictive than expression type
543 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
544 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
545 = Type safety: Unchecked cast from {0} to {1}
546 = Cannot perform instanceof check against parameterized type {0}. Use the form {1} instead since further generic type information will be erased at runtime
547 = Cannot perform instanceof check against type parameter {0}. Use instead its erasure {1} instead since further generic type information will be erased at runtime
548 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
549 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
550 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
551 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
552 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
553 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
554 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
555 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
556 = The type {1} cannot extend or implement {0}. A supertype may not specify any wildcard
557 = The generic class {0} may not subclass java.lang.Throwable
558 = Illegal class literal for the type parameter {0}
559 = Type safety: The return type {0} for {1}({2}) from the type {3} needs unchecked conversion to conform to {4} from the type {5}
560 = Name clash: The method {0}({1}) of type {2} has the same erasure as {0}({3}) of type {4} but does not override it
561 = The member type {0}<{1}> must be qualified with a parameterized type, since it is not static
562 = The member type {0} must be parameterized, since it is qualified with a parameterized type
563 = The member type {0} cannot be qualified with a parameterized type, since it is static. Remove arguments from qualifying type {1}
###[obsolete] 564 = Bound conflict: {0} is inherited with conflicting arguments
565 = Duplicate methods named {0} with the parameters ({2}) and ({3}) are defined by the type {1}
566 = Cannot allocate the member type {0} using a parameterized compound name; use its simple name and an enclosing instance of type {1}
567 = Duplicate bound {0}
568 = The array type {0} cannot be used as a type parameter bound
569 = Type safety: Unchecked invocation {0}({3}) of the generic constructor {0}({1}) of type {2}
570 = Type safety: Unchecked invocation {0}({3}) of the generic method {0}({1}) of type {2}
571 = The type parameter {0} is hiding the type {1}
572 = {0} is a raw type. References to generic type {1} should be parameterized
573 = Cannot specify any additional bound {0} when first bound is a type parameter
574 = Type safety : A generic array of {0} is created for a varargs parameter
575 = Illegal qualified access from the type parameter {0}
576 = The nested type {0} is hiding the type parameter {1} of type {2}
577 = The nested type {0} is hiding the type parameter {1} of the generic method {2}({3}) of type {4}
578 = Wildcard is not allowed at this location
579 = Unused type arguments for the non generic method {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>

### FOREACH
580 = Type mismatch: cannot convert from element type {0} to {1}
581 = Can only iterate over an array or an instance of java.lang.Iterable
582 = Can only iterate over an array or an instance of java.util.Collection

### SOURCE LEVEL
590 = Syntax error, type parameters are only available if source level is 1.5
591 = Syntax error, static imports are only available if source level is 1.5
592 = Syntax error, 'for each' statements are only available if source level is 1.5
593 = Syntax error, parameterized types are only available if source level is 1.5
594 = Syntax error, enum declarations are only available if source level is 1.5
595 = Syntax error, varargs are only available if source level is 1.5
596 = Syntax error, annotations are only available if source level is 1.5
597 = Syntax error, annotation declarations are only available if source level is 1.5
598 = Syntax error, annotation declaration cannot have type parameters
599 = Syntax error, enum declaration cannot have type parameters

### ANNOTATIONS
600 = Illegal modifier for the annotation attribute {0}.{1}; only public & abstract are permitted
601 = Extended dimensions are illegal in an annotation attribute declaration
602 = Package annotations must be in file package-info.java
603 = Illegal modifier for the annotation type {0}; only public & abstract are permitted
604 = Illegal modifier for the member annotation type {0}; only public, protected, private, static & abstract are permitted
605 = Invalid type {0} for the annotation attribute {2}.{1}; only primitive type, String, Class, annotation, enumeration are permitted or 1-dimensional arrays thereof
606 = Cycle detected: the annotation type {0} cannot contain attributes of the annotation type itself
607 = Cycle detected: a cycle exists between annotation attributes of {0} and {1}
608 = Duplicate annotation @{0}
609 = The annotation @{0} must define the attribute {1}
610 = Duplicate attribute {0} in annotation @{1}
611 = The attribute {0} is undefined for the annotation type {1}
612 = The value for annotation attribute {0}.{1} must be a class literal
613 = The value for annotation attribute {0}.{1} must be a constant expression
###[obsolete] 614 = The annotation field {0}.{1} must be initialized with a constant expression
615 = Illegal modifier for the annotation field {0}.{1}; only public, static & final are permitted
616 = The annotation type {0} cannot override the method {1}.{2}({3})
617 = Annotation attributes cannot have parameters
618 = Annotation attributes cannot be generic
619 = Annotation type declaration cannot have an explicit superclass
620 = Annotation type declaration cannot have explicit superinterfaces
621 = Duplicate element {0} specified in annotation @{1}
622 = The annotation @{0} is disallowed for this location
623 = The method {0}({1}) of type {2} must override a superclass method
624 = Annotation type declaration cannot have a constructor
625 = The value for annotation attribute {0}.{1} must be some @{2} annotation 
626 = The annotation type {0} should not be used as a superinterface for {1}
627 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superclass method
628 = The deprecated field {0}.{1} should be annotated with @Deprecated
629 = The deprecated method {0}({1}) of type {2} should be annotated with @Deprecated
630 = The deprecated type {0} should be annotated with @Deprecated
631 = Unsupported @SuppressWarnings("{0}")
632 = The value for annotation attribute {0}.{1} must be an array initializer
633 = The value for annotation attribute {0}.{1} must be an enum constant expression
634 = The method {0}({1}) of type {2} must override or implement a supertype method
635 = Unnecessary @SuppressWarnings("{0}")
636 = The method {0}({1}) of type {2} should be tagged with @Override since it actually overrides a superinterface method

### MORE GENERICS
660 = Unused type arguments for the non generic constructor {0}({1}) of type {2}; it should not be parameterized with arguments <{3}>

### CORRUPTED BINARIES
700 = The class file {0} contains a signature ''{1}'' ill-formed at position {2}

### CORRUPTED SOURCES
701 = Cannot read the source from {0}; either the file uses a different encoding than {1} or it is corrupted
702 = Cannot read the source from {0} due to internal exception {1}

### AUTOBOXING
720 = The expression of type {0} is boxed into {1}
721 = The expression of type {0} is unboxed into {1}

### ENUMS
750 = Illegal modifier for the enum {0}; only public is permitted
751 = Illegal modifier for the enum constant {0}; no modifier is allowed
###[obsolete] 752 = Illegal modifier for the local enum {0}; only abstract is permitted
753 = Illegal modifier for the member enum {0}; only public, protected, private & static are permitted
754 = The enum {1} already defines the method {0}({2}) implicitly
755 = The qualified case label {0}.{1} must be replaced with the unqualified enum constant {1}
756 = The type {1} may not subclass {0} explicitly
757 = Cannot invoke super constructor from enum constructor {0}({1})
758 = The enum {2} can only define the abstract method {0}({1}) if it also defines enum constants with corresponding implementations
759 = The field {0}.{1} cannot be referenced from an enum case label; only enum constants can be used in enum switch
760 = Illegal modifier for the enum constructor; only private is permitted.
761 = The enum constant {1} needs a corresponding case label in this enum switch on {0}
762 = Cannot refer to the static enum field {0}.{1} within an initializer
763 = The enum constant {2} must implement the abstract method {0}({1})
764 = The enum constant {0} cannot define abstract methods
765 = The method {1} cannot be abstract in the enum constant {0}

### VARARGS
800 = Extended dimensions are illegal for a variable argument
801 = The argument of type {0} should explicitly be cast to {1} for the invocation of the varargs method {2}({3}) from type {4}. It could alternatively be cast to {5} for a varargs invocation
802 = The argument of type {0} should explicitly be cast to {1} for the invocation of the varargs constructor {2}({3}). It could alternatively be cast to {4} for a varargs invocation
803 = Varargs methods should only override or be overridden by other varargs methods unlike {2}.{0}({1}) and {4}.{0}({3})

### GENERIC JAVADOC
850 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
851 = The method {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
852 = Incorrect number of type arguments for generic method <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
853 = The parameterized method <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
854 = The method {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>
855 = Bound mismatch: The generic constructor {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} extends {6}>
856 = The constructor {0}({1}) of type {2} is not generic; it cannot be parameterized with arguments <{3}>
857 = Incorrect number of type arguments for generic constructor <{3}>{0}({1}) of type {2}; it cannot be parameterized with arguments <{4}>
858 = The parameterized constructor <{3}>{0}({1}) of type {2} is not applicable for the arguments ({4})
859 = The constructor {0}({1}) of raw type {2} is no longer generic; it cannot be parameterized with arguments <{3}>

### ELABORATIONS
## Access restrictions
78592 = The type {1} is not accessible due to restriction on classpath entry {0}
78593 = The type {1} is not accessible due to restriction on required project {0}
78594 = The type {1} is not accessible due to restriction on required library {0}
78596 = The field {1} from the type {2} is not accessible due to restriction on classpath entry {0}
78597 = The field {1} from the type {2} is not accessible due to restriction on required project {0}
78598 = The field {1} from the type {2} is not accessible due to restriction on required library {0}
78600 = The constructor {1} is not accessible due to restriction on classpath entry {0}
78601 = The constructor {1} is not accessible due to restriction on required project {0}
78602 = The constructor {1} is not accessible due to restriction on required library {0}
78604 = The method {1} from the type {2} is not accessible due to restriction on classpath entry {0}
78606 = The method {1} from the type {2} is not accessible due to restriction on required library {0}
78605 = The method {1} from the type {2} is not accessible due to restriction on required project {0}

### ObjectTeams:
1000001 = The type org.objectteams.Team cannot have a superclass or superinterfaces
1000002 = Illegal modifier for team class {0}.

### TEAMS AND ROLES
1102101 = Illegal modifier for role {0}. Roles cannot be static (OTJLD 1.2.1).
1102102 = Illegal access modifier for role {0}. Only public and protected are allowed here (OTJLD 1.2.1(a)).
1102103 = The method {1}({2}) from the role type {0} is not visible (OTJLD 1.2.1(e)).
1102104 = Type mismatch: cannot convert from {0} to {1} because type anchors could not be proven to be the same instance (OTJLD 1.2.2(e)).
1102105 = Cannot access non-public field {0} via externalized role {1} (OTJLD 1.2.1(e)).
1102106 = Cannot access non-public method {1} via externalized role {0} (OTJLD 1.2.1(e)). 
1102107 = Cannot access non-public constructor {1} to instantiate externalized role {0} (OTJLD 1.2.1(e)).
1102108 = Indirect tsuper method inherited from {0} is not visible (OTJLD 1.2.1(e)).
1102109 = Non-constant initialization not allowed for a static field of a role class (OTJLD 1.2.1(g)).

1102200 = Cannot externalize non-public role {0} (OTJLD 1.2.2(a)).
#unused: 1102201 = 
1102202 = Missing anchor (team instance) for role type {0} outside its team context (OTJLD 1.2.2(b)).
1102203 = Not a valid type anchor: type {0} is not the enclosing team of role type {1} (OTJLD 1.2.2(b)).
1102204 = ''{0}'' cannot be used as type anchor for an externalized role: is not a team (OTJLD 1.2.2(b)).
1102205 = Cannot resolve type anchor {0} (OTJLD 1.2.2(b)).
1102206 = Cannot resolve type {0}: no such role in team {1} (OTJLD 1.2.2(b)).
1102207 = Path syntax for externalized role type is deprecated (OTJLD 1.2.2(b)).
1102208 = Invalid qualification for role type {0}, externalized roles must be anchored to a team instance, otherwise use the simple name (OTJLD 1.2.2(b)).
1102209 = Invalid externalized use of role type {0}, anchor is not final (OTJLD 1.2.2(c)).
1102210 = Anchor {0} for the role type {1} is not final (OTJLD 1.2.2(c)).
1102211 = Not a valid type anchor for externalized role {0}, need a final variable (OTJLD 1.2.2(c)).
1102212 = Creation of a role instance outside its enclosing team must have the form ''t.new R()''\n where t is a valid type anchor according to OTJLD 1.2.2(c) and R is the simple name of a role class (OTJLD 1.2.2(h)).
1102213 = Illegal qualified use of type {0}: path contains no suitable team anchor (OTJLD 1.2.2(f)).
1102214 = Externalized role {0} is not allowed in this position (OTJLD 1.2.2(g)).
1102215 = Cannot sub-class an externalized role type (OTJLD 1.2.2(g)).
1102216 = Detected a cycle while resolve field {0}.{1} as a team anchor (OTJLD 1.2.2).
1102217 = Illegal import for role type {0}: roles cannot be imported (OTJLD 1.2.2(i)).
1102300 = Illegal qualified use of non-public role {0} (OTJLD 1.2.3(b)).
1102301 = Illegal parameterized use of non-public role {0} (OTJLD 1.2.3(b)).

1102501 = Role file must contain exactly one toplevel type (OTJLD 1.2.5(b)).
1102502 = The name of role file {0} does not match the role type {1} which it defines (OTJLD 1.2.5(b)).
1102503 = Package name {0} does not match the name of the enclosing package {1} for role file {2} (OTJLD 1.2.5(c)).
1102504 = Package declaration {0} refers to the enclosing team of role file {1}.\nMust use a ''team package'' declaration (OTJLD 1.2.5(c)).
1102505 = Enclosing team {0} not found for role file {1} (OTJLD 1.2.5(c)).
1102506 = Javadoc: Missing tag for role file {0} (OTJLD 1.2.5(d)).
1102507 = Javadoc: Type {0} is not a role file of this team (OTJLD 1.2.5(d)).
1102508 = Javadoc: {0} cannot be resolved to a role of this team (OTJLD 1.2.5(d)).
1102509 = Javadoc: {0} is an inline role, whereas the @role tag should only be used for role files (OTJLD 1.2.5(d)).
1102510 = Javadoc: Illegal @role tag, type {0} is not a team (OTJLD 1.2.5(d)).
1102511 = The enum type {0} illegally resides in a role file of team {1} (OTJLD 1.2.5(e)). 

1103001 = Illegal ''extends'' for a regular class: superclass {0} is a team (OTJLD 1.3).
1103101 = Role class {0} cannot override an interface of the same name (OTJLD 1.3.1(c)).
1103102 = Role interface {0} cannot override class of the same name (OTJLD 1.3.1(c)).
1103103 = Cannot override the final role {0} (OTJLD 1.3.1(c)).
1103104 = Role {0} must override a role from a super team (OTJLD 1.3.1(c)).
1103105 = Role {0} should be tagged with @Override since it actually overrides a superteam role (OTJLD 1.3.1(c)).
1103106 = Type mismatch: cannot convert from {0} to {1} because static types of enclosing teams differs (OTJLD 1.3.1(d)).
1103107 = Cannot use ''tsuper'' in method {0}, enclosing type {1} is not a role (OTJLD 1.3.1(f)).
1103108 = Illegal tsuper call: role {0} has no implicit super class (OTJLD 1.3.1(f)).
1103109 = Invalid qualified ''tsuper'': type {1} contains no role corresponding to {0} (OTJLD 1.3.1(f)).
1103110 = Illegal tsuper call: can only invoke the method being overridden by the current method (OTJLD 1.3.1(f)).
1103111 = Cannot reduce the visibility of role {0} to {1}, implicit super-role is ''{2}'' (OTJLD 1.3.1(h)).
1103112 = Cannot reduce the visibility of the inherited method from implicit super class {0} (OTJLD 1.3.1(h)).
1103113 = The return type of implicitly inherited method {0} is not compatible to the return type of explicitly inherited method {1} (1.3.1(k)).
1103201 = Cannot extend {1}.{0} because enclosing type {1} is not an enclosing type of this role (OTJLD 1.3.2(a)).
1103202 = Role inherits incompatible ''extends'' declarations: {0} is not a sub-type of {1} (OTJLD 1.3.2(b)).
1103203 = Illegal tsuper call. Must use a constructor of newly introduced super-class {0} (OTJLD 1.3.2(c)).
1103204 = Method {0} inherited from regular super class {1} is not visible outside the role {2} (OTJLD 1.3.2(e)).

1104001 = Role type {0} shadows the visible type {1} (OTJLD 1.4(a)).
1104002 = Field declaration {0} conflicts with an implicitly inherited field (OTJLD 1.4(b)).

1105001 = Regular role cannot override team {0} (OTJLD 1.5(a)).
1105002 = Member types not allowed in regular roles. Mark class {0} as a team if {1} should be its role (OTJLD 1.5(a,b)). 
1105003 = Team {0} cannot extend its enclosing team {1} (OTJLD 1.5(c)).
1105004 = Name clash for implicit super types of role {0}: {1} and {2} are incomparable (OTJLD 1.5(d)).


### ROLE-BASE-BINDING
1201001 = Overlapping role hierarchies: role is subtype of these bound roles: {0} (OTJLD 2.1(c)).
1201002 = Illegal redefinition: {0} is not a sub-type of baseclass {1} as inherited from {2} (OTJLD 2.1(c)).
1201003 = Role inherits incompatible ''playedBy'' declaration(s): {0} is not comparable to {1} (OTJLD 2.1(c)).
1201004 = Cannot bind role class {0} to {1} because implicit super-role is already bound to {2} (OTJLD 2.1(d)).
1201101 = Unsupported feature (incomplete implementation): binding interface {0} as base of {1} (OTJLD 2.1.1).
1201201 = Member type {0} cannot be used as the base class of {1} (OTJLD 2.1.2(b)).
1201202 = Role {1} cannot be played by {0}: this name stands for a role of the same team (OTJLD 2.1.2(a)).
1201203 = Illegal base class {0}, is an enclosing type of {1} (OTJLD 2.1.2(b)).
1201204 = Base class/member type circularity via chain {0} (OTJLD 2.1.2(b)).
1201205 = Overriding access restriction of base class {0} (OTJLD 2.1.2(c)).
1201206 = PlayedBy binding overrides finalness of base class {0} (OTJLD 2.1.2(c)).
1201207 = Trying to override access restriction of confined base class {0} (OTJLD 2.1.2(c)).
1201208 = "base" import is not allowed in regular class {0} (OTJLD 2.1.2(d)).
1201209 = "base" import is not allowed in a role file (OTJLD 2.1.2(d)).
1201210 = It is recommended that base class {0} be imported with the modifier "base" (OTJLD 2.1.2(d)).
1201211 = Qualified reference to base class {0} is deprecated, should use a base import instead (OTJLD 2.1.2(d)).
1201212 = Bound base class {0} cannot have free type parameters (OTJLD 2.1.2(e)).
1201213 = Role {0} cannot have free type parameters when binding to a base class (OTJLD 2.1.2(e)).

1201299 = Base class {0} is deprecated.

1201308 = Illegal base import: this package is not provided by the declared base plug-in(s) {0} (OT/Equinox).
1201309 = Illegal base import: this package is not provided by the declared base plug-in {0} but by plug-in {1} (OT/Equinox).
1201310 = Illegal base import: no aspect binding declared for team {0} (OT/Equinox).
1201311 = Decapsulating base class {0} by means of a forced export. Note, that additionally a corresponing declaration is needed in config.ini (OTJLD 2.1.2(c) + OT/Equinox).
1201312 = This messages should never be seen ({0}).
1201313 = The forced-exported type {0} cannot be accessed other than as a role's base class (OT/Equinox).
1201314 = The declared base plug-in contains on or more split packages; please manually ensure that class {0} is actually provided by plug-in {1} (OT/Equinox).
1201315 = A declared base plug-in contains on or more split packages; please manually ensure that class {0} is actually provided by one of the plug-ins {1} (OT/Equinox).

1202001 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).
1202002 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).\nPerhaps you should just remove this cast?
1202003 = Types {0} and {1} are compatible only by lowering, which is not allowed here (OTJLD 2.2(b)).\nPerhaps you should use a local variable to get the lowered expression? 
1202004 = Assigning a {0} to {1} is ambiguous: will not apply lowering to {2} because direct upcasting is sufficient (OTJLD 2.2(f)).

1203101 = The constructor {0} is undefined. Note that bound roles per default only have a lifting constructor (OTJLD 2.3.1(b)).
1203102 = Need custom lifting constructor, because super class has no argumentless constructor {0} (OTJLD 2.3.1(c)).
1203103 = Lifting constructor cannot have explicit super-call (OTJLD 2.3.1(c)).

1203201 = Illegal type for argument {0}: declared lifting not allowed in static methods (OTJLD 2.3.2(a)).
1203202 = Qualified type name not allowed here. Type after keyword "as" must be a role of the enclosing team {0} (OTJLD 2.3.2(a)).
1203203 = Declared lifting is only allowed in signatures of team methods (OTJLD 2.3.2(a)).
1203204 = The primitive type {0} is not allowed in declared lifting type (OTJLD 2.3.2(a)).
1203205 = Illegal type {0}, need a role type for declared lifting (OTJLD 2.3.2(a)).
1203206 = Cannot lift to role {0} because it is not played by a base class (OTJLD 2.3.2(a)).
1203207 = Class {0} is incompatible to the base class {2} of role {1}. Lifting not possible (OTJLD 2.3.2(a)).
1203208 = Syntax error in declared lifting. Array dimensions do not match (OTJLD 2.3.2(c)).
1203209 = Illegal type bound: {0} is not a role type (OTJLD 2.3.2(e)).
1203210 = Bound mismatch: The generic method {0}({1}) of type {2} is not applicable for the arguments ({3}). The inferred type {4} is not a valid substitute for the bounded parameter <{5} base {6}> (OTJLD 2.3.2(e)).

1203401 = Potential ambiguity in role binding. The base ''{0}'' is bound to the following roles: {1} (OTJLD 2.3.4(a)).
1203402 = Lifting type {0} to role {1} is definitely ambiguous (OTJLD 2.3.4(b)).

1204101 = Cannot invoke the lifting constructor {0} to create an externalized role (OTJLD 2.4.1(a)).
1204102 = Argument to lifting constructor {0} is not a freshly created base object (of type {1}); may cause a DuplicateRoleException at runtime (OTJLD 2.4.1(c)).
1204201 = Illegal base constructor call: method {0} is not a constructor of a bound role (OTJLD 2.4.2).
1204202 = Illegal call to base constructor: this constructor is a lifting constructor (OTJLD 2.4.2).
1204203 = Cannot use this constructor from class {0}, because it creates a base instance of type {2} wheras a base instance of type {1} is required (OTJLD 2.4.2(c)).
1204204 = Constructor call (tsuper) must be inside a role constructor (OTJLD 2.4.2).
1204205 = Call to base constructor is not first statement (after super-call) (OTJLD 2.4.2(b)).
1204206 = Missing call to a base constructor, class {0} is a bound role (OTJLD 2.4.2(b)).
1204207 = Illegal call to base constructor: constructor called by ''{0}'' already calls a base constructor (OTJLD 2.4.2(b)).
1204208 = Access restriction of constructor {0} is overridden by this base constructor call (OTJLD 2.4.2(b)).
1204209 = This constructor conflicts with the lifting constructor (using argument lowering).\nDue to lower visibility external allocations will use the lifting constructor instead (OTJLD 2.4.2(d)).
1204301 = Dangerous instantitation. To avoid a WrongRoleException at runtime role {0} should be used instead (OTJLD 2.4.3).

1205001 = Team {0} may need to be declared abstract, because irrelevance for abstract role {1} could not be shown (OTJLD 2.5(b)).
1205002 = Team {0} must be declared abstract, because abstract role {1} is relevant (OTJLD 2.5(b)).

1206001 = Cannot use ''base'' as a prefix since ''{0}'' is not a team (OTJLD 2.6(a)).
1206002 = Illegal qualified use of ''base'', type ''{0}'' is not a bound role (OTJLD 2.6(a)).
1206003 = Cannot use ''base'' in the regular method ''{0}'' (OTJLD 2.6(c)).
1206004 = Cannot use explicit base call in method bindings (OTJLD 2.6).
1206005 = Illegal use of keyword ''base'' (OTJLD 2.6).
1206006 = Access restriction of field {0} in type {1} is overridden by this reference (OTJLD 2.6(g)).
1206007 = Access restriction of method {0} in type {1} is overridden by this call (OTJLD 2.6(g)).

### CALLOUT
1301001 = Method binding not allowed here, {0} is not a role (OTJLD 3.1(a)).
1301002 = Method binding not allowed here, role {0} is not played by a base class (OTJLD 3.1(a)).
1301003 = No method {0} found in type {1} to resolve method designator (OTJLD 3.1(c)).
1301004 = Method specifier ''{0}'' is ambiguous for the type {1}. Please use the exact method signature to disambiguate (OTJLD 3.1(c)).
1301005 = Method designator binds to a method returning {0} whereas return type {1} is specified (OTJLD 3.1(c)).
1301006 = Method specifier finds no direct match, argument of closest match is {0} instead of {1} (OTJLD 3.1(c)).
1301007 = A non-abstract role method exists for this callout-binding. Use callout-override (''=>'') if you want to override it (OTJLD 3.1(e)).
1301008 = Trying to bind an abstract method as callout override (OTJLD 3.1(e)).
1301009 = Callout binding tries to override method {0} from the same role class (OTJLD 3.1(e)).
1301010 = Callout binding conflicts with inherited callout binding from class {0}. Use ''=>'' if you want to override it (OTJLD 3.1(f)).
1301011 = The method is bound as callout more than once: {0} (OTJLD 3.1(g)).
1301012 = Callout method does not declare {0} which is thrown by the bound base method (OTJLD 3.1(h)).
#1301013
1301014 = Inherited abstract method {0} is implicitly bound as an inferred callout (OTJLD 3.1(j)).
1301015 = Unresolved self call {0} is implicitly bound by an inferred callout (OTJLD 3.1(j)).

1302001 = Unused mapping for parameter {0} is ignored (OTJLD 3.2).
1302002 = Syntax error: parameter mapping allowed only if methods are specified with their signatures (OTJLD 3.2(a)).
1302003 = Parameter {0} is mapped more than once (OTJLD 3.2(b)).
1302004 = Incomplete parameter mapping: argument {0} of base method {1} is not mapped (OTJLD 3.2(b)).
1302005 = Wrong mapping direction for parameter {0}, should use {1} unless mapping 'result' (OTJLD 3.2(b)). 
1302006 = Wrong mapping direction for \"result\", should use {0} (OTJLD 3.2(c)). 
1302007 = Illegal mapping for 'result'. {0} returns void (OTJLD 3.2(c)).
1302008 = Illegal use of 'result' in parameter mapping: wrong binding direction (OTJLD 3.2(c)).
1302009 = Cannot use 'result' here: method {0} returns void (OTJLD 3.2(c)).
1302010 = ''result'' can only be mapped to ''result'' (OTJLD 3.2(c)).
1302011 = Method {0} does not provide enough arguments for binding to method {1} (OTJLD 3.2(e)).
1302012 = Cannot implicitly map signatures for callout binding:\nBase method {1} returns void whereas role method {0} expects {2} (OTJLD 3.2(e)).
1302013 = Parameter mapping not allowed here: enclosing type {0} is an interface (OTJLD 3.2(a)).

1303001 = Type mismatch in callout binding: cannot convert from {0} to {1} (OTJLD 3.3(d)).
1303002 = When mapping the {0}. argument of {1}: cannot convert from {2} to {3} (OTJLD 3.3(d)).
1303003 = The bound method {0} does not provide required result of type {1} (OTJLD 3.3(d)).
1303004 = Callout binding:\nReturn of base method {1} is incompatible with return expected by method {0}:\nCan't convert {3} to {2} (OTJLD 3.3(d)).

1304001 = This class overrides access restrictions of its base class. Compile with -decapsulation for details (OTJLD 3.4(a)).
1304002 = Access restriction of method {0} in type {1} is overridden by this method binding (OTJLD 3.4(a)).
1304003 = The method {0} from type {1} is not visible for this binding (enable decapsulation? OTJLD 3.4).
1304004 = The private base feature {0} from type {1} is not available via the base type {2} (OTJLD 3.4(d)). 

1305001 = Callout binding cannot resolve field {0} in type {1} (OTJLD 3.5).
1305002 = Field specifier ''{0}'' resolves to type {1} whereas type {2} is specified (OTJLD 3.5(a)).
1305003 = Accessing field {1} through method "{0}" has no effect (OTJLD 3.5(b)).
1305004 = Binding method ''{0}'' via callout as field setter cannot return a value (OTJLD 3.5(b)).
1305005 = Cannot bind role method {0} to field {1}:\nMissing parameter of type {2} (OTJLD 3.5(b)).
1305006 = When binding field {1} via callout to role method {0}:\nIncompatible types: can't convert {3} to {2} (OTJLD 3.5(b)).
1305007 = When binding role method {0} via callout to field {1}:\nIncompatible types: can't convert {3} to {2} (OTJLD 3.5(b)).
1305008 = Access restriction of field {0} in type {1} is overridden by this binding (OTJLD 3.5(e)).
1305009 = A non-abstract role method exists for this callout-binding. Use callout-override (''=>'') if you want to override it (OTJLD 3.5(g)).
1305010 = Callout binding conflicts with inherited callout binding from class {0}. Use ''=>'' if you want to override it (OTJLD 3.5(g)).
1305011 = Assignment to unresolved variable {0} implicitly uses callout to base field '{1}' (OTJLD 3.5(h)).
1305012 = Reference {1} implicitly uses callout getter to base field '{1}' (OTJLD 3.5(h)).
1305013 = Method call {0} tries to re-use an inferred callout to field (OTJLD 3.5(h)). 

### CALLIN
1401001 = Method binding not allowed here, {0} is not a role (OTJLD 4.1(b)).
1401002 = Method binding not allowed here, role {0} is not played by a base class (OTJLD 4.1(b)).
1401003 = Callin mapping not allowed here, because lifting to role {0} is not possible due to a reported binding ambiguity (OTJLD 4.1(b)).
1401004 = No method {0} found in type {1} to resolve method designator (OTJLD 4.1(c)).
1401005 = Method specifier "{0}" is ambiguous for the type {1}. Please use the exact method signature to disambiguate (OTJLD 4.1(c)).
1401006 = Method designator binds to a method returning {0} whereas return type {1} is specified (OTJLD 4.1(c)).
1401007 = Method specifier finds no direct match, argument of closest match is {0} instead of {1} (OTJLD 4.1(c)).
1401008 = Duplicate callin name "{0}" (OTJLD 4.1(e)).
1401009 = Trying to bind final method {0} from class {1} via class {2}; must bind directly to {1} (OTJLD 4.1(f).
1401010 = Base method does not declare {0} which is thrown by the bound role method (OTJLD 4.1(g)).

1401099 = Bound base method {0} is deprecated.

1402001 = Modifier ''callin'' not allowed here. Enclosing class {0} is not a role (OTJLD 4.2(d)).
1402002 = Illegal modifier(s) ''{0}'' for method {1}, callin method must not declare visibility (OTJLD 4.2(d)).
1402003 = Method {0} cannot be called explicitly; is a callin method (OTJLD 4.2(d)).
1402004 = Cannot bind method {0} as callout; is a callin method (OTJLD 4.2(d)).
1402005 = Cannot bind method {0} using "replace": need a callin method (OTJLD 4.2(d)).
1402006 = Cannot bind callin method {0} using "{1}" (OTJLD 4.2(d)).
1402007 = Modifier "callin" not allowed here; trying to override a method from {0} which is not a callin method (OTJLD 4.2(d)). 
1402008 = Missing modifier "callin"; trying to override a method from {0} which is a callin method (OTJLD 4.2(d)).
1402009 = Class inherits incompatible methods {0} from {1} and {2}: conflict between callin and regular method (OTJLD 4.2(d)).

1403001 = Illegal method in base call, can only call base version of the enclosing method {0} (OTJLD 4.3(a)).
1403002 = Base call "{0}" does not match the signature of the enclosing callin method (OTJLD 4.3(a)).
1403003 = Potentially missing base call in callin method (OTJLD 4.3(b)).
1403004 = This callin method has no base call (OTJLD 4.3(b)).
1403005 = Potentially duplicate base call (OTJLD 4.3(c)).
1403006 = This callin method calls its base method more than once (OTJLD 4.3(c)).
1403007 = Illegal callin binding: base method requires a result of type {0}, which is not provided in this binding nor by a base call in the bound role method (OTJLD 4.3(e)).
1403008 = Fragile callin binding: base method requires a result of type {0}, which is not provided in this binding. If no base call is issued, the result will be missing, causing a ResultNotProvidedException to be thrown (OTJLD 4.3(e)).
1403009 = Fragile callin binding: base method requires a result of type {0}, which is not provided in this binding. If no base call is issued, the result will be uninitialized (null) (OTJLD 4.3(e)).
1403010 = Incompatible callin binding: callin method {1} contains a base super call but bound base method {0} is not overriding a super method (OTJLD 4.3(f)).
1403011 = Base super call bypasses both the bound base method and also other callin bindings if any are bound to the same base method (OTJLD 4.3(f)).

1404000 = Syntax error: parameter mapping allowed only if methods are specified with their signatures (OTJLD 4.4(a)).
1404001 = Illegal use of 'result' in parameter mapping: wrong binding direction (OTJLD 4.4(a)).
1404002 = Method {1} does not provide enough arguments for binding to method {0} (OTJLD 4.4(a)).
1404003 = Parameter {0} is mapped more than once (OTJLD 4.4(a)).
1404004 = Cannot use 'result' here: method {0} returns void (OTJLD 4.4(a)).
1404005 = Incomplete parameter mapping: argument {0} of role method {1} is not mapped (OTJLD 4.4(a)).
1404006 = Illegal expression in callin replace binding: here 'result' must be mapped to 'result' (OTJLD 4.4(b)).
1404007 = Role method "{1} {0}" bound via replace callin to method "{4} {3}" must not return a non-void result (OTJLD 4.4(b)).
1404008 = Callin binding:\nReturn of method {1} is incompatible with return expected by base method {0}:\nCan't convert {3} to {2} (OTJLD 4.4(b)).
1404009 = When binding method "{1} {0}" via callin to method "{4} {3}":\nBase call would require to convert return type {5} to {2} (OTJLD 4.4(b)).
1404010 = ''result'' can only be mapped to ''result'' (OTJLD 4.4(b)).
1404011 = Illegal expression in callin replace binding: cannot use base method argument in compound expression (OTJLD 4.4(b)).
1404012 = Illegal direction ''->'' in parameter mapping for non-replace callin (OTJLD 4.4(c)).

1405001 = Type mismatch in callin binding: cannot convert from {0} to {1} (OTJLD 4.5(d)).
1405002 = When mapping the {0}. argument of {1}: cannot convert from {2} to {3} (OTJLD 4.5(d)).
# unused:
1405003 = The bound method {0} does not provide required result of type {1} (OTJLD 4.5(d)).
1405004 = When mapping the {2}. argument: types {0} and {1} are not two-way compatible as required for replace bindings (OTJLD 4.5(d)).

1406001 = Access restriction of method {0} in type {1} will be overridden if the bound callin method issues a base call (OTJLD 4.6).
1406002 = The private base feature {0} from type {1} is not available via the base type {2} (OTJLD 4.6(a)). 


1407001 = Cannot bind static base method {1} to non-static role method {0} (OTJLD 4.7(b)).
1407002 = Cannot bind non-static base method {1} to static callin method {0} via replace (OTJLD 4.7(d)).

1408001 = ''{4}'' callin bindings {0}.{1} and {2}.{3} refer to the same base method; must declare precedence of these bindings (OTJLD 4.8).
1408002 = 'precedence' declaration not allowed here, enclosing type {0} is neither a team nor a role (OTJLD 4.8(a)).
1408003 = Callin binding {0} not found in type {1} (OTJLD 4.8(b)).
1408004 = Type {0} is not a legal prefix for callin {1}; Need a role or team type (OTJLD 4.8(b)).
1408005 = Contradictory precedence lists for type {0} cannot be combined (OTJLD 4.8(d)).
1408006 = Cannot define precedence for '{0}' and '{1}', because the former overrides the latter (OTJLD 4.8(e)).

1409001 = This callin binding admits covariant base method return types, must use a fresh type variable like "<E extends {0}> E" as the role side return type (OTJLD 4.9.3(c)).

1410001 = Type variable {0} cannot capture a covariant return type because it is used more than once in this signature (OTJLD 4.10(a)). 

### ACTIVATION/PREDICATES
1502001 = Within statement {0} must have a team instance as argument (OTJLD 5.2(a)).
1504001 = Guard predicate throws checked exception {0} (OTJLD 5.4(c)).
1504101 = ''{0}'' cannot be resolved, perhaps you need to add signatures to the callin binding in order to expose parameters/result? (OTJLD 5.4.1(a)).
1504201 = Illegal base guard: {0} is not a bound role (OTJLD 5.4.2(f)).

### API
1601001 = Cannot use class literal for role {0} in a static context (OTJLD 6.1(c)).
1601002 = Cannot use unqualified class literal for role {0} outside its enclosing team (OTJLD 6.1(c)).
1602001 = The method {0} conflicts with a predefined method of same name and number of arguments (OTJLD 6.2).

### ENCAPSULATION
1702001 = Role class tries to override the builtin type org.objectteams.Team.{0} (OTJLD 7.2(a)).
1702002 = An array of confined roles is not compatible with java.lang.Object (OTJLD 7.2(b)).

### DEPENDENT TYPES
1900210 = Parameter is not a value (OTJLD 9.2.1).
1900211 = Parameter cannot be resolved to an object reference (OTJLD 9.2.1).
1900212 = Parameter '{0}' cannot be resolved (OTJLD 9.2.1).
1900213 = Parameter does not match declaration of value parameter '{0} {1}' (OTJLD 9.2.1).
1900214 = Illegal use of value parameter: type {0} does not declare a value parameter at position {1} (OTJLD 9.2.1).
1900215 = Cannot rebind the anchor {1} of type variable {0} (OTJLD 9.2.1(a)). 

### SYNTAX
2000101 = Object Teams keyword not enabled in this scope (OTJLD A.0.1).
2000201 = Illegal superclass: Name of method ''{0}'' inherited from {1} is a keyword in OT/J (OTJLD A.0.2).
2000301 = Illegal identifier {0} (OTJLD A.0.3).

2001101 = Illegal ''playedBy'' declaration: class {0} is not a role (OTJLD A.1.1(a)).

2003101 = Method binding must be directly contained in a class (OTJLD A.3.1).
2003201 = Modifiers not allowed in short callout bindings (OTJLD A.3.2).
2003202 = Illegal modifier for callout binding (only public, protected or private allowed here) (OTJLD A.3.2).
2003203 = Illegal method designator: illegal constructor reference or missing return type (OTJLD A.3.2). 
2003204 = Syntax error: missing return type for method designator (OTJLD A.3.2). 
2003301 = Modifiers not allowed in callin bindings (OTJLD A.3.3).
2003302 = Syntax error: callin label must be a simple name (OTJLD A.3.3).
2003303 = Callin modifier (before, after or replace) missing for callin-binding {0} (OTJLD A.3.3).
2003304 = Syntax error: right hand side of method binding does not specify type arguments (OTJLD A.3.3).
2003501 = Method designator must not specify a modifier (OTJLD A.3.5). 

2006001 = Syntax Error: Declared lifting type not support in this position (OTJLD A.6(a)).

2007001 = Syntax Error: missing boolean expression for guard predicate (OTJLD A.7.1).

2009001 = Illegal position for value parameter {0}: must be a parameter of a single name type reference(OTJLD A.9(a)).

2010001 = Syntax error, SingleTypeReference expected (OTJLD 1.2.4(c)).


### LIMITATIONS
2100001 = Limitation: generics not supported in this position.
2100002 = Internal method for lifting type {0} to role {1} has not been generated.
2100003 = Compiler limitation: This constructor seems to request lifting of an argument. However, the self call in {0} of class {1} passes its arguments in an unexpected way. Cannot perform required transitive byte-code translation.
2100006 = Requesting role file {0} for team {1} which is already compiled (compiler limitation).
2100007 = Role {0} is missing for binary team {1} (compiler limitation).
2100008 = Role {0} has not been copied (implicit inheritance) to team {1} (probably caused by some other error).
2100009 = Cannot generate method {0}, tsuper method has corrupt byte code. This may or may not be caused by an internal compiler error.
2100010 = Implicit super role has incompatible byte code, offending name: ''{0}''. It was probably compiled for an incompatible JRE.
2100011 = Limitation: compiler support for dependent types is incomplete: {0}.
2100012 = Using an experimental feature: {0}.
2100013 = Role {0} seems to refer to a stale tsuper role {1}: tsuper method {2} cannot be resolved. Please consider a full rebuild of the enclosing project.
2100014 = Role {1} seems to require recompilation due to changes in super role {0}. Please consider a full rebuild of the enclosing project.
2100015 = A synthetic access method for field {1} is missing in type {0}. Please consider a full rebuild of the enclosing project.
2100016 = Compiler limitation: wrong compilation order for role {0} as a member of team {1} which is already compiled.
2100017 = Incremental compilation problem: role {0} consists of a source and a binary part. 
2100018 = Internal representations of role {0} and {1} are inconsistent.
2100019 = Compiler limitation: unsupported compilation order: ''{0}''.
2100020 = Incomplete incremental build: did not generate callin binding for role {0}.\nBefore launching the application please perform a full build.
2100021 = Cannot resolve base class for type {0}: unexpected build order (please consider a full build for this project).
2100022 = Compiler limitation: the role field {0} can only be static if it is also declared final.
2100023 = Illegally copied default constructor, role {0} is a bound role.
2100024 = Modifier "readonly" is not yet supported.
2100025 = Missing compiler implementation: {0} is not yet supported.
2100026 = Base class {0} appears to be a system class, which means that load time weaving could fail\nif this class is loaded from rt.jar/the bootstrap classpath.\nIf the runtime throws an UnsupportedFeatureException launching the program in JPLIS mode might help.
2100027 = Dangerous callin binding: {0} is used internally during lifting, which could create infinite recursion.
2100028 = Compiler limitation: can't copy annotation ''{0}'' for implicitly inherited field ''{1}'': unexpected structure.
2100029 = Class file {0} has incompatible OT/J byte code version {1}, please consider a full build of the declaring project.

## EXPERIMENTAL
2200001 = Type {0} does not support team migration, only applicable for roles (OT/J experimental feature).
2200002 = Team migration not possible because enclosing team class {0} is not final (OT/J experimental feature). 
2200003 = Argument is not a valid new team anchor (OT/J experimental feature).
2200004 = The special method {1}.migrateToTeam({2}) is not applicable for the arguments ({0}).
2200005 = Team migration not possible in the current implementation because {0} is a bound role class (OT/J experimental feature).

2200010 = Type {0} does not support base migration; this is only applicable for roles (OT/J experimental feature).
2200011 = Role {0} cannot support base migration because it is not bound to a base class (OT/J experimental feature).
2200012 = The special method {1}.migrateToBase({2}) is not applicable for the arguments ({0}). 

